import { addIcons } from 'ionicons';
import { arrowBackSharp, caretBackSharp, chevronBack, chevronForward, close, closeCircle, closeSharp, menuOutline, menuSharp, reorderTwoSharp, reorderThreeOutline, searchOutline, searchSharp } from 'ionicons/icons';
import { defineComponent, ref, inject, h, computed, provide, shallowRef, watch, onUnmounted, getCurrentInstance, Teleport } from 'vue';
import { setupConfig, isPlatform, actionSheetController, alertController, loadingController, modalController, pickerController, popoverController, toastController } from '@ionic/core';
export { IonicSafeString, actionSheetController, alertController, createAnimation, createGesture, getPlatforms, getTimeGivenProgression, iosTransitionAnimation, isPlatform, loadingController, mdTransitionAnimation, menuController, modalController, pickerController, popoverController, toastController } from '@ionic/core';
import { applyPolyfills, defineCustomElements } from '@ionic/core/loader';
import { useRoute } from 'vue-router';

const UPDATE_VALUE_EVENT = 'update:modelValue';
const MODEL_VALUE = 'modelValue';
const ROUTER_LINK_VALUE = 'routerLink';
const NAV_MANAGER = 'navManager';
const ROUTER_PROP_REFIX = 'router';
const getComponentClasses = (classes) => {
    var _a;
    return ((_a = classes) === null || _a === void 0 ? void 0 : _a.split(' ')) || [];
};
const getElementClasses = (ref, componentClasses, defaultClasses = []) => {
    var _a;
    return [...Array.from(((_a = ref.value) === null || _a === void 0 ? void 0 : _a.classList) || []), ...defaultClasses]
        .filter((c, i, self) => !componentClasses.has(c) && self.indexOf(c) === i);
};
/**
* Create a callback to define a Vue component wrapper around a Web Component.
*
* @prop name - The component tag name (i.e. `ion-button`)
* @prop componentProps - An array of properties on the
* component. These usually match up with the @Prop definitions
* in each component's TSX file.
* @prop componentOptions - An object that defines additional
* options for the component such as router or v-model
* integrations.
*/
const defineContainer = (name, componentProps = [], componentOptions = {}) => {
    const { modelProp, modelUpdateEvent, routerLinkComponent } = componentOptions;
    /**
    * Create a Vue component wrapper around a Web Component.
    * Note: The `props` here are not all properties on a component.
    * They refer to whatever properties are set on an instance of a component.
    */
    const Container = defineComponent((props, { attrs, slots, emit }) => {
        const containerRef = ref();
        const classes = new Set(getComponentClasses(attrs.class));
        const onVnodeBeforeMount = (vnode) => {
            // Add a listener to tell Vue to update the v-model
            if (vnode.el) {
                vnode.el.addEventListener(modelUpdateEvent.toLowerCase(), (e) => {
                    emit(UPDATE_VALUE_EVENT, (e === null || e === void 0 ? void 0 : e.target)[modelProp]);
                });
            }
        };
        let handleClick;
        if (routerLinkComponent) {
            const navManager = inject(NAV_MANAGER);
            handleClick = (ev) => {
                const routerProps = Object.keys(props).filter(p => p.startsWith(ROUTER_PROP_REFIX));
                if (routerProps.length === 0)
                    return;
                let navigationPayload = { event: ev };
                routerProps.forEach(prop => {
                    navigationPayload[prop] = props[prop];
                });
                navManager.navigate(navigationPayload);
            };
        }
        return () => {
            getComponentClasses(attrs.class).forEach(value => {
                classes.add(value);
            });
            let propsToAdd = Object.assign(Object.assign({}, props), { ref: containerRef, class: getElementClasses(containerRef, classes), onClick: (routerLinkComponent) ? handleClick : props.onClick, onVnodeBeforeMount: (modelUpdateEvent) ? onVnodeBeforeMount : undefined });
            if (props.onClick) {
                const oldClick = props.onClick;
                propsToAdd.onClick = (ev) => {
                    oldClick(ev);
                    if (!ev.defaultPrevented) {
                        handleClick(ev);
                    }
                };
            }
            if (modelProp) {
                propsToAdd = Object.assign(Object.assign({}, propsToAdd), { [modelProp]: props.hasOwnProperty('modelValue') ? props.modelValue : props[modelProp] });
            }
            return h(name, propsToAdd, slots.default && slots.default());
        };
    });
    Container.displayName = name;
    Container.props = componentProps;
    if (modelProp) {
        Container.props.push(MODEL_VALUE);
        Container.emits = [UPDATE_VALUE_EVENT];
    }
    if (routerLinkComponent) {
        Container.props.push(ROUTER_LINK_VALUE);
    }
    return Container;
};

/* eslint-disable */
const IonAvatar = /*@__PURE__*/ defineContainer('ion-avatar');
const IonBackdrop = /*@__PURE__*/ defineContainer('ion-backdrop', [
    'visible',
    'tappable',
    'stopPropagation',
    'ionBackdropTap'
]);
const IonBadge = /*@__PURE__*/ defineContainer('ion-badge', [
    'color'
]);
const IonButton = /*@__PURE__*/ defineContainer('ion-button', [
    'color',
    'buttonType',
    'disabled',
    'expand',
    'fill',
    'routerDirection',
    'routerAnimation',
    'download',
    'href',
    'rel',
    'shape',
    'size',
    'strong',
    'target',
    'type',
    'ionFocus',
    'ionBlur'
], {
    "routerLinkComponent": true
});
const IonButtons = /*@__PURE__*/ defineContainer('ion-buttons', [
    'collapse'
]);
const IonCard = /*@__PURE__*/ defineContainer('ion-card', [
    'color',
    'button',
    'type',
    'disabled',
    'download',
    'href',
    'rel',
    'routerDirection',
    'routerAnimation',
    'target'
], {
    "routerLinkComponent": true
});
const IonCardContent = /*@__PURE__*/ defineContainer('ion-card-content');
const IonCardHeader = /*@__PURE__*/ defineContainer('ion-card-header', [
    'color',
    'translucent'
]);
const IonCardSubtitle = /*@__PURE__*/ defineContainer('ion-card-subtitle', [
    'color'
]);
const IonCardTitle = /*@__PURE__*/ defineContainer('ion-card-title', [
    'color'
]);
const IonCheckbox = /*@__PURE__*/ defineContainer('ion-checkbox', [
    'color',
    'name',
    'checked',
    'indeterminate',
    'disabled',
    'value',
    'ionChange',
    'ionFocus',
    'ionBlur',
    'ionStyle'
], {
    "modelProp": "checked",
    "modelUpdateEvent": "ionChange"
});
const IonChip = /*@__PURE__*/ defineContainer('ion-chip', [
    'color',
    'outline'
]);
const IonCol = /*@__PURE__*/ defineContainer('ion-col', [
    'offset',
    'offsetXs',
    'offsetSm',
    'offsetMd',
    'offsetLg',
    'offsetXl',
    'pull',
    'pullXs',
    'pullSm',
    'pullMd',
    'pullLg',
    'pullXl',
    'push',
    'pushXs',
    'pushSm',
    'pushMd',
    'pushLg',
    'pushXl',
    'size',
    'sizeXs',
    'sizeSm',
    'sizeMd',
    'sizeLg',
    'sizeXl'
]);
const IonContent = /*@__PURE__*/ defineContainer('ion-content', [
    'color',
    'fullscreen',
    'forceOverscroll',
    'scrollX',
    'scrollY',
    'scrollEvents',
    'ionScrollStart',
    'ionScroll',
    'ionScrollEnd'
]);
const IonDatetime = /*@__PURE__*/ defineContainer('ion-datetime', [
    'name',
    'disabled',
    'readonly',
    'min',
    'max',
    'displayFormat',
    'displayTimezone',
    'pickerFormat',
    'cancelText',
    'doneText',
    'yearValues',
    'monthValues',
    'dayValues',
    'hourValues',
    'minuteValues',
    'monthNames',
    'monthShortNames',
    'dayNames',
    'dayShortNames',
    'pickerOptions',
    'placeholder',
    'value',
    'ionCancel',
    'ionChange',
    'ionFocus',
    'ionBlur',
    'ionStyle'
], {
    "modelProp": "value",
    "modelUpdateEvent": "ionChange"
});
const IonFab = /*@__PURE__*/ defineContainer('ion-fab', [
    'horizontal',
    'vertical',
    'edge',
    'activated'
], {
    "routerLinkComponent": true
});
const IonFabButton = /*@__PURE__*/ defineContainer('ion-fab-button', [
    'color',
    'activated',
    'disabled',
    'download',
    'href',
    'rel',
    'routerDirection',
    'routerAnimation',
    'target',
    'show',
    'translucent',
    'type',
    'size',
    'closeIcon',
    'ionFocus',
    'ionBlur'
], {
    "routerLinkComponent": true
});
const IonFabList = /*@__PURE__*/ defineContainer('ion-fab-list', [
    'activated',
    'side'
]);
const IonFooter = /*@__PURE__*/ defineContainer('ion-footer', [
    'translucent'
]);
const IonGrid = /*@__PURE__*/ defineContainer('ion-grid', [
    'fixed'
]);
const IonHeader = /*@__PURE__*/ defineContainer('ion-header', [
    'collapse',
    'translucent'
]);
const IonImg = /*@__PURE__*/ defineContainer('ion-img', [
    'alt',
    'src',
    'ionImgWillLoad',
    'ionImgDidLoad',
    'ionError'
]);
const IonInfiniteScroll = /*@__PURE__*/ defineContainer('ion-infinite-scroll', [
    'threshold',
    'disabled',
    'position',
    'ionInfinite'
]);
const IonInfiniteScrollContent = /*@__PURE__*/ defineContainer('ion-infinite-scroll-content', [
    'loadingSpinner',
    'loadingText'
]);
const IonInput = /*@__PURE__*/ defineContainer('ion-input', [
    'fireFocusEvents',
    'color',
    'accept',
    'autocapitalize',
    'autocomplete',
    'autocorrect',
    'autofocus',
    'clearInput',
    'clearOnEdit',
    'debounce',
    'disabled',
    'enterkeyhint',
    'inputmode',
    'max',
    'maxlength',
    'min',
    'minlength',
    'multiple',
    'name',
    'pattern',
    'placeholder',
    'readonly',
    'required',
    'spellcheck',
    'step',
    'size',
    'type',
    'value',
    'ionInput',
    'ionChange',
    'ionBlur',
    'ionFocus',
    'ionStyle'
], {
    "modelProp": "value",
    "modelUpdateEvent": "ionChange"
});
const IonItem = /*@__PURE__*/ defineContainer('ion-item', [
    'color',
    'button',
    'detail',
    'detailIcon',
    'disabled',
    'download',
    'href',
    'rel',
    'lines',
    'routerAnimation',
    'routerDirection',
    'target',
    'type'
], {
    "routerLinkComponent": true
});
const IonItemDivider = /*@__PURE__*/ defineContainer('ion-item-divider', [
    'color',
    'sticky'
]);
const IonItemGroup = /*@__PURE__*/ defineContainer('ion-item-group');
const IonItemOption = /*@__PURE__*/ defineContainer('ion-item-option', [
    'color',
    'disabled',
    'download',
    'expandable',
    'href',
    'rel',
    'target',
    'type'
]);
const IonItemOptions = /*@__PURE__*/ defineContainer('ion-item-options', [
    'side',
    'ionSwipe'
]);
const IonItemSliding = /*@__PURE__*/ defineContainer('ion-item-sliding', [
    'disabled',
    'ionDrag'
]);
const IonLabel = /*@__PURE__*/ defineContainer('ion-label', [
    'color',
    'position',
    'ionColor',
    'ionStyle'
]);
const IonList = /*@__PURE__*/ defineContainer('ion-list', [
    'lines',
    'inset'
]);
const IonListHeader = /*@__PURE__*/ defineContainer('ion-list-header', [
    'color',
    'lines'
]);
const IonMenu = /*@__PURE__*/ defineContainer('ion-menu', [
    'contentId',
    'menuId',
    'type',
    'disabled',
    'side',
    'swipeGesture',
    'maxEdgeStart',
    'ionWillOpen',
    'ionWillClose',
    'ionDidOpen',
    'ionDidClose',
    'ionMenuChange'
]);
const IonMenuButton = /*@__PURE__*/ defineContainer('ion-menu-button', [
    'color',
    'disabled',
    'menu',
    'autoHide',
    'type'
]);
const IonMenuToggle = /*@__PURE__*/ defineContainer('ion-menu-toggle', [
    'menu',
    'autoHide'
]);
const IonNavLink = /*@__PURE__*/ defineContainer('ion-nav-link', [
    'component',
    'componentProps',
    'routerDirection',
    'routerAnimation'
]);
const IonNote = /*@__PURE__*/ defineContainer('ion-note', [
    'color'
]);
const IonProgressBar = /*@__PURE__*/ defineContainer('ion-progress-bar', [
    'type',
    'reversed',
    'value',
    'buffer',
    'color'
]);
const IonRadio = /*@__PURE__*/ defineContainer('ion-radio', [
    'color',
    'name',
    'disabled',
    'value',
    'ionStyle',
    'ionFocus',
    'ionBlur'
], {
    "modelProp": "value",
    "modelUpdateEvent": "ionChange"
});
const IonRadioGroup = /*@__PURE__*/ defineContainer('ion-radio-group', [
    'allowEmptySelection',
    'name',
    'value',
    'ionChange'
], {
    "modelProp": "value",
    "modelUpdateEvent": "ionChange"
});
const IonRange = /*@__PURE__*/ defineContainer('ion-range', [
    'color',
    'debounce',
    'name',
    'dualKnobs',
    'min',
    'max',
    'pin',
    'snaps',
    'step',
    'ticks',
    'disabled',
    'value',
    'ionChange',
    'ionStyle',
    'ionFocus',
    'ionBlur'
], {
    "modelProp": "value",
    "modelUpdateEvent": "ionChange"
});
const IonRefresher = /*@__PURE__*/ defineContainer('ion-refresher', [
    'pullMin',
    'pullMax',
    'closeDuration',
    'snapbackDuration',
    'pullFactor',
    'disabled',
    'ionRefresh',
    'ionPull',
    'ionStart'
]);
const IonRefresherContent = /*@__PURE__*/ defineContainer('ion-refresher-content', [
    'pullingIcon',
    'pullingText',
    'refreshingSpinner',
    'refreshingText'
]);
const IonReorder = /*@__PURE__*/ defineContainer('ion-reorder');
const IonReorderGroup = /*@__PURE__*/ defineContainer('ion-reorder-group', [
    'disabled',
    'ionItemReorder'
]);
const IonRippleEffect = /*@__PURE__*/ defineContainer('ion-ripple-effect', [
    'type'
]);
const IonRow = /*@__PURE__*/ defineContainer('ion-row');
const IonSearchbar = /*@__PURE__*/ defineContainer('ion-searchbar', [
    'color',
    'animated',
    'autocomplete',
    'autocorrect',
    'cancelButtonIcon',
    'cancelButtonText',
    'clearIcon',
    'debounce',
    'disabled',
    'inputmode',
    'enterkeyhint',
    'placeholder',
    'searchIcon',
    'showCancelButton',
    'spellcheck',
    'type',
    'value',
    'ionInput',
    'ionChange',
    'ionCancel',
    'ionClear',
    'ionBlur',
    'ionFocus',
    'ionStyle'
], {
    "modelProp": "value",
    "modelUpdateEvent": "ionChange"
});
const IonSegment = /*@__PURE__*/ defineContainer('ion-segment', [
    'color',
    'disabled',
    'scrollable',
    'value',
    'ionChange',
    'ionSelect',
    'ionStyle'
], {
    "modelProp": "value",
    "modelUpdateEvent": "ionChange"
});
const IonSegmentButton = /*@__PURE__*/ defineContainer('ion-segment-button', [
    'disabled',
    'layout',
    'type',
    'value'
], {
    "modelProp": "value",
    "modelUpdateEvent": "ionChange"
});
const IonSelect = /*@__PURE__*/ defineContainer('ion-select', [
    'disabled',
    'cancelText',
    'okText',
    'placeholder',
    'name',
    'selectedText',
    'multiple',
    'interface',
    'interfaceOptions',
    'compareWith',
    'value',
    'ionChange',
    'ionCancel',
    'ionFocus',
    'ionBlur',
    'ionStyle'
], {
    "modelProp": "value",
    "modelUpdateEvent": "ionChange"
});
const IonSelectOption = /*@__PURE__*/ defineContainer('ion-select-option', [
    'disabled',
    'value'
]);
const IonSkeletonText = /*@__PURE__*/ defineContainer('ion-skeleton-text', [
    'animated'
]);
const IonSlide = /*@__PURE__*/ defineContainer('ion-slide');
const IonSlides = /*@__PURE__*/ defineContainer('ion-slides', [
    'options',
    'pager',
    'scrollbar',
    'ionSlidesDidLoad',
    'ionSlideTap',
    'ionSlideDoubleTap',
    'ionSlideWillChange',
    'ionSlideDidChange',
    'ionSlideNextStart',
    'ionSlidePrevStart',
    'ionSlideNextEnd',
    'ionSlidePrevEnd',
    'ionSlideTransitionStart',
    'ionSlideTransitionEnd',
    'ionSlideDrag',
    'ionSlideReachStart',
    'ionSlideReachEnd',
    'ionSlideTouchStart',
    'ionSlideTouchEnd'
]);
const IonSpinner = /*@__PURE__*/ defineContainer('ion-spinner', [
    'color',
    'duration',
    'name',
    'paused'
]);
const IonSplitPane = /*@__PURE__*/ defineContainer('ion-split-pane', [
    'contentId',
    'disabled',
    'when',
    'ionSplitPaneVisible'
]);
const IonText = /*@__PURE__*/ defineContainer('ion-text', [
    'color'
]);
const IonTextarea = /*@__PURE__*/ defineContainer('ion-textarea', [
    'fireFocusEvents',
    'color',
    'autocapitalize',
    'autofocus',
    'clearOnEdit',
    'debounce',
    'disabled',
    'inputmode',
    'enterkeyhint',
    'maxlength',
    'minlength',
    'name',
    'placeholder',
    'readonly',
    'required',
    'spellcheck',
    'cols',
    'rows',
    'wrap',
    'autoGrow',
    'value',
    'ionChange',
    'ionInput',
    'ionStyle',
    'ionBlur',
    'ionFocus'
], {
    "modelProp": "value",
    "modelUpdateEvent": "ionChange"
});
const IonThumbnail = /*@__PURE__*/ defineContainer('ion-thumbnail');
const IonTitle = /*@__PURE__*/ defineContainer('ion-title', [
    'color',
    'size',
    'ionStyle'
]);
const IonToggle = /*@__PURE__*/ defineContainer('ion-toggle', [
    'color',
    'name',
    'checked',
    'disabled',
    'value',
    'ionChange',
    'ionFocus',
    'ionBlur',
    'ionStyle'
], {
    "modelProp": "checked",
    "modelUpdateEvent": "ionChange"
});
const IonToolbar = /*@__PURE__*/ defineContainer('ion-toolbar', [
    'color'
]);
const IonVirtualScroll = /*@__PURE__*/ defineContainer('ion-virtual-scroll', [
    'approxItemHeight',
    'approxHeaderHeight',
    'approxFooterHeight',
    'headerFn',
    'footerFn',
    'items',
    'itemHeight',
    'headerHeight',
    'footerHeight',
    'renderItem',
    'renderHeader',
    'renderFooter',
    'nodeRender',
    'domRender'
]);

const ael = (el, eventName, cb, opts) => el.addEventListener(eventName.toLowerCase(), cb, opts);
const rel = (el, eventName, cb, opts) => el.removeEventListener(eventName.toLowerCase(), cb, opts);
const IonicVue = {
    async install(_app, config = {}) {
        if (typeof window !== 'undefined') {
            setupConfig(Object.assign(Object.assign({}, config), { _ael: ael, _rel: rel }));
            await applyPolyfills();
            await defineCustomElements(window, {
                exclude: ['ion-tabs'],
                ce: (eventName, opts) => new CustomEvent(eventName.toLowerCase(), opts),
                ael,
                rel
            });
        }
    }
};

const IonBackButton = defineComponent({
    name: 'IonBackButton',
    setup(_, { attrs, slots }) {
        const ionRouter = inject('navManager');
        const onClick = () => {
            const defaultHref = attrs['default-href'] || attrs['defaultHref'];
            const routerAnimation = attrs['router-animation'] || attrs['routerAnimation'];
            ionRouter.handleNavigateBack(defaultHref, routerAnimation);
        };
        return () => {
            return h('ion-back-button', Object.assign({ onClick }, attrs), slots.default && slots.default());
        };
    }
});

const IonPage = defineComponent({
    name: 'IonPage',
    props: {
        isInOutlet: { type: Boolean, default: false },
        registerIonPage: { type: Function, default: () => { } }
    },
    mounted() {
        this.$props.registerIonPage(this.$refs.ionPage);
    },
    setup(props, { attrs, slots }) {
        const hidePageClass = (props.isInOutlet) ? 'ion-page-invisible' : '';
        return () => {
            return h('div', Object.assign(Object.assign({ ['class']: `ion-page ${hidePageClass}` }, attrs), { ref: 'ionPage' }), slots.default && slots.default());
        };
    }
});

const LIFECYCLE_WILL_ENTER = 'ionViewWillEnter';
const LIFECYCLE_DID_ENTER = 'ionViewDidEnter';
const LIFECYCLE_WILL_LEAVE = 'ionViewWillLeave';
const LIFECYCLE_DID_LEAVE = 'ionViewDidLeave';
const ids = { main: 0 };
const generateId = (type = 'main') => {
    var _a;
    const id = ((_a = ids[type]) !== null && _a !== void 0 ? _a : 0) + 1;
    ids[type] = id;
    return (id).toString();
};
// TODO types
const fireLifecycle = (vueComponentRef, lifecycle) => {
    if (vueComponentRef && vueComponentRef.value && vueComponentRef.value[lifecycle]) {
        vueComponentRef.value[lifecycle]();
    }
};

let viewDepthKey = Symbol(0);
const IonRouterOutlet = defineComponent({
    name: 'IonRouterOutlet',
    setup(_, { attrs }) {
        const route = useRoute();
        const depth = inject(viewDepthKey, 0);
        const matchedRouteRef = computed(() => {
            const matchedRoute = route.matched[depth];
            if (matchedRoute && attrs.tabs && route.matched[depth + 1]) {
                return route.matched[route.matched.length - 1];
            }
            return matchedRoute;
        });
        provide(viewDepthKey, depth + 1);
        const ionRouterOutlet = ref();
        const id = generateId('ion-router-outlet');
        // TODO types
        const ionRouter = inject('navManager');
        const viewStacks = inject('viewStacks');
        const components = shallowRef([]);
        let skipTransition = false;
        // The base url for this router outlet
        let parentOutletPath;
        watch(matchedRouteRef, (currentValue, previousValue) => {
            /**
             * We need to make sure that we are not re-rendering
             * the same view if navigation changes in a sub-outlet.
             * This is mainly for tabs when outlet 1 renders ion-tabs
             * and outlet 2 renders the individual tab view. We don't
             * want outlet 1 creating a new ion-tabs instance every time
             * we switch tabs.
             */
            if (currentValue !== previousValue) {
                setupViewItem(matchedRouteRef);
            }
        });
        const canStart = () => {
            const stack = viewStacks.getViewStack(id);
            if (!stack || stack.length <= 1)
                return false;
            /**
             * We only want to outlet of the entering view
             * to respond to this gesture, so check
             * to make sure the view is in the outlet we want.
             */
            const routeInfo = ionRouter.getCurrentRouteInfo();
            const enteringViewItem = viewStacks.findViewItemByRouteInfo({ pathname: routeInfo.pushedByRoute }, id);
            return !!enteringViewItem;
        };
        const onStart = async () => {
            const routeInfo = ionRouter.getCurrentRouteInfo();
            const { routerAnimation } = routeInfo;
            const enteringViewItem = viewStacks.findViewItemByRouteInfo({ pathname: routeInfo.pushedByRoute }, id);
            const leavingViewItem = viewStacks.findViewItemByRouteInfo(routeInfo, id);
            if (leavingViewItem) {
                let animationBuilder = routerAnimation;
                const enteringEl = enteringViewItem.ionPageElement;
                const leavingEl = leavingViewItem.ionPageElement;
                /**
                * If we are going back from a page that
                * was presented using a custom animation
                * we should default to using that
                * unless the developer explicitly
                * provided another animation.
                */
                const customAnimation = enteringViewItem.routerAnimation;
                if (animationBuilder === undefined &&
                    // todo check for tab switch
                    customAnimation !== undefined) {
                    animationBuilder = customAnimation;
                }
                leavingViewItem.routerAnimation = animationBuilder;
                await transition(enteringEl, leavingEl, 'back', ionRouter.canGoBack(2), true, animationBuilder);
            }
            return Promise.resolve();
        };
        const onEnd = (shouldContinue) => {
            if (shouldContinue) {
                skipTransition = true;
                /**
                 * Use the same logic as clicking
                 * ion-back-button to determine where
                 * to go back to.
                 */
                ionRouter.handleNavigateBack();
            }
            else {
                /**
                 * In the event that the swipe
                 * gesture was aborted, we should
                 * re-hide the page that was going to enter.
                 */
                const routeInfo = ionRouter.getCurrentRouteInfo();
                const enteringViewItem = viewStacks.findViewItemByRouteInfo({ pathname: routeInfo.pushedByRoute }, id);
                enteringViewItem.ionPageElement.setAttribute('aria-hidden', 'true');
                enteringViewItem.ionPageElement.classList.add('ion-page-hidden');
            }
        };
        watch(ionRouterOutlet, () => {
            ionRouterOutlet.value.swipeHandler = {
                canStart,
                onStart,
                onEnd
            };
        });
        const transition = (enteringEl, leavingEl, direction, // TODO types
        showGoBack, progressAnimation, animationBuilder) => {
            return new Promise(resolve => {
                if (skipTransition) {
                    skipTransition = false;
                    return resolve(false);
                }
                if (enteringEl === leavingEl) {
                    return resolve(false);
                }
                requestAnimationFrame(() => {
                    requestAnimationFrame(async () => {
                        enteringEl.classList.add('ion-page-invisible');
                        const result = await ionRouterOutlet.value.commit(enteringEl, leavingEl, {
                            deepWait: true,
                            duration: direction === undefined || direction === 'root' || direction === 'none' ? 0 : undefined,
                            direction,
                            showGoBack,
                            progressAnimation,
                            animationBuilder
                        });
                        return resolve(result);
                    });
                });
            });
        };
        const handlePageTransition = async () => {
            const routeInfo = ionRouter.getCurrentRouteInfo();
            const { routerDirection, routerAction, routerAnimation } = routeInfo;
            const enteringViewItem = viewStacks.findViewItemByRouteInfo(routeInfo, id);
            const leavingViewItem = viewStacks.findLeavingViewItemByRouteInfo(routeInfo, id);
            const enteringEl = enteringViewItem.ionPageElement;
            if (enteringViewItem === leavingViewItem)
                return;
            fireLifecycle(enteringViewItem.vueComponentRef, LIFECYCLE_WILL_ENTER);
            if (leavingViewItem) {
                let animationBuilder = routerAnimation;
                const leavingEl = leavingViewItem.ionPageElement;
                fireLifecycle(leavingViewItem.vueComponentRef, LIFECYCLE_WILL_LEAVE);
                /**
                * If we are going back from a page that
                * was presented using a custom animation
                * we should default to using that
                * unless the developer explicitly
                * provided another animation.
                */
                const customAnimation = enteringViewItem.routerAnimation;
                if (animationBuilder === undefined &&
                    routerDirection === 'back' &&
                    // todo check for tab switch
                    customAnimation !== undefined) {
                    animationBuilder = customAnimation;
                }
                leavingViewItem.routerAnimation = animationBuilder;
                await transition(enteringEl, leavingEl, routerDirection, !!routeInfo.pushedByRoute, false, animationBuilder);
                leavingEl.classList.add('ion-page-hidden');
                leavingEl.setAttribute('aria-hidden', 'true');
                if (!(routerAction === 'push' && routerDirection === 'forward')) {
                    const shouldLeavingViewBeRemoved = routerDirection !== 'none' && leavingViewItem && (enteringViewItem !== leavingViewItem);
                    if (shouldLeavingViewBeRemoved) {
                        leavingViewItem.mount = false;
                        leavingViewItem.ionPageElement = undefined;
                        leavingViewItem.ionRoute = false;
                    }
                }
                fireLifecycle(leavingViewItem.vueComponentRef, LIFECYCLE_DID_LEAVE);
            }
            else {
                /**
                 * If there is no leaving element, just show
                 * the entering element. Wrap it in an raf
                 * in case ion-content's fullscreen callback
                 * is running. Otherwise we'd have a flicker.
                 */
                requestAnimationFrame(() => enteringEl.classList.remove('ion-page-invisible'));
            }
            fireLifecycle(enteringViewItem.vueComponentRef, LIFECYCLE_DID_ENTER);
            components.value = viewStacks.getChildrenToRender(id);
        };
        const setupViewItem = (matchedRouteRef) => {
            const firstMatchedRoute = route.matched[0];
            if (!parentOutletPath) {
                parentOutletPath = firstMatchedRoute.path;
            }
            /**
             * If no matched route, do not do anything in this outlet.
             * If there is a match, but it the first matched path
             * is not the root path for this outlet, then this view
             * change needs to be rendered in a different outlet.
             * We also add an exception for when the matchedRouteRef is
             * equal to the first matched route (i.e. the base router outlet).
             * This logic is mainly to help nested outlets/multi-tab
             * setups work better.
             */
            if (!matchedRouteRef.value ||
                (matchedRouteRef.value !== firstMatchedRoute && firstMatchedRoute.path !== parentOutletPath)) {
                return;
            }
            const currentRoute = ionRouter.getCurrentRouteInfo();
            let enteringViewItem = viewStacks.findViewItemByRouteInfo(currentRoute, id);
            if (!enteringViewItem) {
                enteringViewItem = viewStacks.createViewItem(id, matchedRouteRef.value.components.default, matchedRouteRef.value, currentRoute);
                viewStacks.add(enteringViewItem);
            }
            if (!enteringViewItem.mount) {
                enteringViewItem.mount = true;
                enteringViewItem.registerCallback = () => {
                    handlePageTransition();
                    enteringViewItem.registerCallback = undefined;
                };
            }
            else {
                handlePageTransition();
            }
            components.value = viewStacks.getChildrenToRender(id);
        };
        if (matchedRouteRef.value) {
            setupViewItem(matchedRouteRef);
        }
        /**
         * Remove stack data for this outlet
         * when outlet is destroyed otherwise
         * we will see cached view data.
         */
        onUnmounted(() => viewStacks.clear(id));
        // TODO types
        const registerIonPage = (viewItem, ionPageEl) => {
            const oldIonPageEl = viewItem.ionPageElement;
            viewStacks.registerIonPage(viewItem, ionPageEl);
            /**
             * If there is a registerCallback,
             * then this component is being registered
             * as a result of a navigation change.
             */
            if (viewItem.registerCallback) {
                viewItem.registerCallback();
                /**
                 * If there is no registerCallback, then
                 * this component is likely being re-registered
                 * as a result of a hot module replacement.
                 * We need to see if the oldIonPageEl has
                 * .ion-page-invisible. If it does not then we
                 * need to remove it from the new ionPageEl otherwise
                 * the page will be hidden when it is replaced.
                 */
            }
            else if (oldIonPageEl && !oldIonPageEl.classList.contains('ion-page-invisible')) {
                ionPageEl.classList.remove('ion-page-invisible');
            }
        };
        return {
            id,
            components,
            ionRouterOutlet,
            registerIonPage
        };
    },
    render() {
        const { components, registerIonPage } = this;
        return h('ion-router-outlet', { ref: 'ionRouterOutlet' }, 
        // TODO types
        components && components.map((c) => {
            return h(c.vueComponent, {
                ref: c.vueComponentRef,
                key: c.pathname,
                isInOutlet: true,
                registerIonPage: (ionPageEl) => registerIonPage(c, ionPageEl)
            });
        }));
    }
});

const IonTabButton = defineComponent({
    name: 'IonTabButton',
    props: {
        _getTabState: { type: Function, default: () => { return {}; } },
        disabled: Boolean,
        download: String,
        href: String,
        rel: String,
        layout: String,
        selected: Boolean,
        tab: String,
        target: String
    },
    setup(props, { slots }) {
        const ionRouter = inject('navManager');
        const onClick = (ev) => {
            if (ev.cancelable) {
                ev.preventDefault();
            }
            /**
             * Keeping track of the originalHref
             * (i.e. /tabs/tab1) lets us redirect
             * users back to a child page using currentHref
             * (i.e. /tabs/tab1/child).
             */
            const { tab, href, _getTabState } = props;
            const tabState = _getTabState();
            const tappedTab = tabState.tabs[tab] || {};
            const originalHref = tappedTab.originalHref || href;
            const currentHref = tappedTab.currentHref || href;
            const prevActiveTab = tabState.activeTab;
            /**
             * If we are still on the same
             * tab as before, but the base href
             * does not equal the current href,
             * then we must be on a child page and
             * should direct users back to the root
             * of the tab.
             */
            if (prevActiveTab === tab) {
                if (originalHref !== currentHref) {
                    ionRouter.resetTab(tab, originalHref);
                }
            }
            else {
                ionRouter.changeTab(tab, currentHref);
            }
        };
        return () => {
            return h('ion-tab-button', Object.assign({ onClick }, props), slots.default && slots.default());
        };
    }
});

const IonTabs = defineComponent({
    name: 'IonTabs',
    render() {
        const { $slots: slots } = this;
        return h('ion-tabs', {
            style: {
                'display': 'flex',
                'position': 'absolute',
                'top': '0',
                'left': '0',
                'right': '0',
                'bottom': '0',
                'flex-direction': 'column',
                'width': '100%',
                'height': '100%',
                'contain': 'layout size style',
                'z-index': '0'
            }
        }, [
            h('div', {
                class: 'tabs-inner',
                style: {
                    'position': 'relative',
                    'flex': '1',
                    'contain': 'layout size style'
                }
            }, [
                h(IonRouterOutlet, { tabs: true })
            ]),
            ...slots.default && slots.default()
        ]);
    }
});

const IonTabBar = defineComponent({
    name: 'IonTabBar',
    mounted() {
        const ionRouter = inject('navManager');
        const tabState = {
            activeTab: undefined,
            tabs: {}
        };
        const currentInstance = getCurrentInstance();
        /**
         * For each tab, we need to keep track of its
         * base href as well as any child page that
         * is active in its stack so that when we go back
         * to a tab from another tab, we can correctly
         * show any child pages if necessary.
         */
        currentInstance.subTree.children.forEach((child) => {
            if (child.type && child.type.name === 'IonTabButton') {
                tabState.tabs[child.props.tab] = {
                    originalHref: child.props.href,
                    currentHref: child.props.href,
                    ref: child
                };
                /**
                 * Passing this prop to each tab button
                 * lets it be aware of the state that
                 * ion-tab-bar is managing for it.
                 */
                child.component.props._getTabState = () => tabState;
            }
        });
        const checkActiveTab = (currentRoute) => {
            const childNodes = currentInstance.subTree.children;
            const { tabs, activeTab: prevActiveTab } = tabState;
            const tabKeys = Object.keys(tabs);
            const activeTab = tabKeys
                .find(key => {
                const href = tabs[key].originalHref;
                return currentRoute.pathname.startsWith(href);
            });
            /**
             * For each tab, check to see if the
             * base href has changed. If so, update
             * it in the tabs state.
             */
            childNodes.forEach((child) => {
                if (child.type && child.type.name === 'IonTabButton') {
                    const tab = tabs[child.props.tab];
                    if (!tab || (tab.originalHref !== child.props.href)) {
                        tabs[child.props.tab] = {
                            originalHref: child.props.href,
                            currentHref: child.props.href,
                            ref: child
                        };
                    }
                }
            });
            if (activeTab && prevActiveTab) {
                const prevHref = tabState.tabs[prevActiveTab].currentHref;
                /**
                 * If the tabs change or the url changes,
                 * update the currentHref for the active tab.
                 * Ex: url changes from /tabs/tab1 --> /tabs/tab1/child
                 * If we went to tab2 then back to tab1, we should
                 * land on /tabs/tab1/child instead of /tabs/tab1.
                 */
                if (activeTab !== prevActiveTab || (prevHref !== currentRoute.pathname)) {
                    tabs[activeTab] = Object.assign(Object.assign({}, tabs[activeTab]), { currentHref: currentRoute.pathname + (currentRoute.search || '') });
                }
                /**
                 * If navigating back and the tabs change,
                 * set the previous tab back to its original href.
                 */
                if (currentRoute.routerAction === 'pop' && (activeTab !== prevActiveTab)) {
                    tabs[prevActiveTab] = Object.assign(Object.assign({}, tabs[prevActiveTab]), { currentHref: tabs[prevActiveTab].originalHref });
                }
            }
            const activeChild = childNodes.find((child) => child.el.tab === activeTab);
            const tabBar = this.$refs.ionTabBar;
            if (activeChild && tabBar) {
                ionRouter.handleSetCurrentTab(activeTab);
                tabBar.selectedTab = tabState.activeTab = activeTab;
            }
        };
        ionRouter.registerHistoryChangeListener(checkActiveTab.bind(this));
        checkActiveTab(ionRouter.getCurrentRouteInfo());
    },
    setup(_, { slots }) {
        return () => {
            return h('ion-tab-bar', { ref: 'ionTabBar' }, slots.default && slots.default());
        };
    }
});

const userComponents = shallowRef([]);
const IonApp = defineComponent({
    name: 'IonApp',
    setup(_, { attrs, slots }) {
        return () => {
            return h('ion-app', Object.assign({}, attrs), [slots.default && slots.default(), ...userComponents.value]);
        };
    }
});
/**
 * When rendering user components inside of
 * ion-modal, ion-popover, or ion-nav, the component
 * needs to be created inside of the current application
 * context otherwise libraries such as vue-i18n or vuex
 * will not work properly.
 *
 * `userComponents` renders teleported components as children
 * of `ion-app` within the current application context.
 */
const addTeleportedUserComponent = (component) => {
    userComponents.value = [
        ...userComponents.value,
        component
    ];
};
const removeTeleportedUserComponent = (component) => {
    userComponents.value = userComponents.value.filter(cmp => cmp !== component);
};

const VueDelegate = () => {
    let Component;
    const attachViewToDom = (parentElement, component, componentProps = {}, classes) => {
        /**
         * Ionic Framework passes in modal and popover element
         * refs as props, but if these are not defined
         * on the Vue component instance as props, Vue will
         * warn the user.
         */
        delete componentProps['modal'];
        delete componentProps['popover'];
        const div = document.createElement('div');
        classes && div.classList.add(...classes);
        parentElement.appendChild(div);
        Component = h(Teleport, { to: div }, h(component, Object.assign({}, componentProps)));
        addTeleportedUserComponent(Component);
        return div;
    };
    const removeViewFromDom = () => {
        Component && removeTeleportedUserComponent(Component);
        return Promise.resolve();
    };
    return { attachViewToDom, removeViewFromDom };
};

const IonNav = defineComponent({
    name: 'IonNav',
    setup(_, { slots }) {
        const delegate = VueDelegate();
        return () => {
            return h('ion-nav', { delegate }, slots);
        };
    }
});

const IonIcon = defineComponent({
    name: 'IonIcon',
    props: {
        ariaLabel: String,
        color: String,
        flipRtl: Boolean,
        icon: String,
        ios: String,
        lazy: String,
        md: String,
        mode: String,
        name: String,
        size: String,
        src: String
    },
    setup(props, { slots }) {
        return () => {
            var _a, _b;
            const { icon, ios, md } = props;
            let iconToUse;
            if (ios || md) {
                if (isPlatform('ios')) {
                    iconToUse = (_a = ios !== null && ios !== void 0 ? ios : md) !== null && _a !== void 0 ? _a : icon;
                }
                else {
                    iconToUse = (_b = md !== null && md !== void 0 ? md : ios) !== null && _b !== void 0 ? _b : icon;
                }
            }
            else {
                iconToUse = icon;
            }
            return h('ion-icon', Object.assign(Object.assign({}, props), { icon: iconToUse }), slots);
        };
    }
});

const defineOverlayContainer = (name, componentProps = [], controller) => {
    // TODO
    const eventPrefix = name.toLowerCase().split('-').join('');
    const eventListeners = [
        { componentEv: `${eventPrefix}willpresent`, frameworkEv: 'onWillPresent' },
        { componentEv: `${eventPrefix}didpresent`, frameworkEv: 'onDidPresent' },
        { componentEv: `${eventPrefix}willdismiss`, frameworkEv: 'onWillDismiss' },
        { componentEv: `${eventPrefix}diddismiss`, frameworkEv: 'onDidDismiss' },
    ];
    const Container = defineComponent((props, { slots, emit }) => {
        const overlay = ref();
        const onVnodeMounted = async () => {
            const isOpen = props.isOpen;
            isOpen && (await present(props));
        };
        const onVnodeUpdated = async () => {
            var _a, _b;
            const isOpen = props.isOpen;
            if (isOpen) {
                await ((_a = overlay.value) === null || _a === void 0 ? void 0 : _a.present()) || present(props);
            }
            else {
                await ((_b = overlay.value) === null || _b === void 0 ? void 0 : _b.dismiss());
                overlay.value = undefined;
            }
        };
        const onVnodeBeforeUnmount = async () => {
            var _a;
            await ((_a = overlay.value) === null || _a === void 0 ? void 0 : _a.dismiss());
            overlay.value = undefined;
        };
        const present = async (props) => {
            const component = slots.default && slots.default()[0];
            overlay.value = await controller.create(Object.assign(Object.assign({}, props), { component }));
            eventListeners.forEach(eventListener => {
                overlay.value.addEventListener(eventListener.componentEv, () => {
                    emit(eventListener.frameworkEv);
                });
            });
            await overlay.value.present();
        };
        return () => {
            return h('div', {
                style: { display: 'none' },
                onVnodeMounted,
                onVnodeUpdated,
                onVnodeBeforeUnmount
            });
        };
    });
    Container.displayName = name;
    Container.props = [...componentProps, 'isOpen'];
    Container.emits = eventListeners.map(ev => ev.frameworkEv);
    return Container;
};

/* auto-generated vue overlay proxies */
const IonActionSheet = /*@__PURE__*/ defineOverlayContainer('ion-action-sheet', ['animated', 'backdropDismiss', 'buttons', 'cssClass', 'enterAnimation', 'header', 'keyboardClose', 'leaveAnimation', 'mode', 'subHeader', 'translucent'], actionSheetController);
const IonAlert = /*@__PURE__*/ defineOverlayContainer('ion-alert', ['animated', 'backdropDismiss', 'buttons', 'cssClass', 'enterAnimation', 'header', 'inputs', 'keyboardClose', 'leaveAnimation', 'message', 'mode', 'subHeader', 'translucent'], alertController);
const IonLoading = /*@__PURE__*/ defineOverlayContainer('ion-loading', ['animated', 'backdropDismiss', 'cssClass', 'duration', 'enterAnimation', 'keyboardClose', 'leaveAnimation', 'message', 'mode', 'showBackdrop', 'spinner', 'translucent'], loadingController);
const IonModal = /*@__PURE__*/ defineOverlayContainer('ion-modal', ['animated', 'backdropDismiss', 'component', 'componentProps', 'cssClass', 'enterAnimation', 'keyboardClose', 'leaveAnimation', 'mode', 'presentingElement', 'showBackdrop', 'swipeToClose'], modalController);
const IonPicker = /*@__PURE__*/ defineOverlayContainer('ion-picker', ['animated', 'backdropDismiss', 'buttons', 'columns', 'cssClass', 'duration', 'enterAnimation', 'keyboardClose', 'leaveAnimation', 'mode', 'showBackdrop'], pickerController);
const IonPopover = /*@__PURE__*/ defineOverlayContainer('ion-popover', ['animated', 'backdropDismiss', 'component', 'componentProps', 'cssClass', 'enterAnimation', 'event', 'keyboardClose', 'leaveAnimation', 'mode', 'showBackdrop', 'translucent'], popoverController);
const IonToast = /*@__PURE__*/ defineOverlayContainer('ion-toast', ['animated', 'buttons', 'color', 'cssClass', 'duration', 'enterAnimation', 'header', 'keyboardClose', 'leaveAnimation', 'message', 'mode', 'position', 'translucent'], toastController);

const useBackButton = (priority, handler) => {
    const callback = (ev) => ev.detail.register(priority, handler);
    const unregister = () => document.removeEventListener('ionBackButton', callback);
    document.addEventListener('ionBackButton', callback);
    return { unregister };
};
const useIonRouter = () => {
    const { canGoBack } = inject('navManager');
    return {
        canGoBack
    };
};
const useKeyboard = () => {
    let isOpen = ref(false);
    let keyboardHeight = ref(0);
    const showCallback = (ev) => {
        isOpen.value = true;
        keyboardHeight.value = ev.detail.keyboardHeight;
    };
    const hideCallback = () => {
        isOpen.value = false;
        keyboardHeight.value = 0;
    };
    const unregister = () => {
        if (typeof window !== 'undefined') {
            window.removeEventListener('ionKeyboardDidShow', showCallback);
            window.removeEventListener('ionKeyboardDidHide', hideCallback);
        }
    };
    if (typeof window !== 'undefined') {
        window.addEventListener('ionKeyboardDidShow', showCallback);
        window.addEventListener('ionKeyboardDidHide', hideCallback);
    }
    return {
        isOpen,
        keyboardHeight,
        unregister
    };
};

const oldModalCreate = modalController.create.bind(modalController);
modalController.create = (options) => {
    return oldModalCreate(Object.assign(Object.assign({}, options), { delegate: VueDelegate() }));
};
const oldPopoverCreate = popoverController.create.bind(popoverController);
popoverController.create = (options) => {
    return oldPopoverCreate(Object.assign(Object.assign({}, options), { delegate: VueDelegate() }));
};

// Icons that are used by internal components
addIcons({
    'arrow-back-sharp': arrowBackSharp,
    'caret-back-sharp': caretBackSharp,
    'chevron-back': chevronBack,
    'chevron-forward': chevronForward,
    'close': close,
    'close-circle': closeCircle,
    'close-sharp': closeSharp,
    'menu-outline': menuOutline,
    'menu-sharp': menuSharp,
    'reorder-two-sharp': reorderTwoSharp,
    'reorder-three-outline': reorderThreeOutline,
    'search-outline': searchOutline,
    'search-sharp': searchSharp,
});

export { IonActionSheet, IonAlert, IonApp, IonAvatar, IonBackButton, IonBackdrop, IonBadge, IonButton, IonButtons, IonCard, IonCardContent, IonCardHeader, IonCardSubtitle, IonCardTitle, IonCheckbox, IonChip, IonCol, IonContent, IonDatetime, IonFab, IonFabButton, IonFabList, IonFooter, IonGrid, IonHeader, IonIcon, IonImg, IonInfiniteScroll, IonInfiniteScrollContent, IonInput, IonItem, IonItemDivider, IonItemGroup, IonItemOption, IonItemOptions, IonItemSliding, IonLabel, IonList, IonListHeader, IonLoading, IonMenu, IonMenuButton, IonMenuToggle, IonModal, IonNav, IonNavLink, IonNote, IonPage, IonPicker, IonPopover, IonProgressBar, IonRadio, IonRadioGroup, IonRange, IonRefresher, IonRefresherContent, IonReorder, IonReorderGroup, IonRippleEffect, IonRouterOutlet, IonRow, IonSearchbar, IonSegment, IonSegmentButton, IonSelect, IonSelectOption, IonSkeletonText, IonSlide, IonSlides, IonSpinner, IonSplitPane, IonTabBar, IonTabButton, IonTabs, IonText, IonTextarea, IonThumbnail, IonTitle, IonToast, IonToggle, IonToolbar, IonVirtualScroll, IonicVue, useBackButton, useIonRouter, useKeyboard };
//# sourceMappingURL=index.js.map

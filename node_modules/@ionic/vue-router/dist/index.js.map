{"version":3,"file":"index.js","sources":["../dist-transpiled/locationHistory.js","../dist-transpiled/utils.js","../dist-transpiled/router.js","../dist-transpiled/regexp.js","../dist-transpiled/viewStacks.js","../dist-transpiled/index.js"],"sourcesContent":["export const createLocationHistory = () => {\n    const locationHistory = [];\n    const tabsHistory = {};\n    const add = (routeInfo) => {\n        switch (routeInfo.routerAction) {\n            case \"replace\":\n                replaceRoute(routeInfo);\n                break;\n            case \"pop\":\n                pop(routeInfo);\n                break;\n            default:\n                addRoute(routeInfo);\n                break;\n        }\n        if (routeInfo.routerDirection === 'root') {\n            clearHistory();\n            addRoute(routeInfo);\n        }\n    };\n    const update = (routeInfo) => {\n        const locationIndex = locationHistory.findIndex(x => x.id === routeInfo.id);\n        if (locationIndex > -1) {\n            locationHistory.splice(locationIndex, 1, routeInfo);\n        }\n        const tabArray = tabsHistory[routeInfo.tab || ''];\n        if (tabArray) {\n            const tabIndex = tabArray.findIndex(x => x.id === routeInfo.id);\n            if (tabIndex > -1) {\n                tabArray.splice(tabIndex, 1, routeInfo);\n            }\n            else {\n                tabArray.push(routeInfo);\n            }\n        }\n        else if (routeInfo.tab) {\n            tabsHistory[routeInfo.tab] = [routeInfo];\n        }\n    };\n    const replaceRoute = (routeInfo) => {\n        const routeInfos = getTabsHistory(routeInfo.tab);\n        routeInfos && routeInfos.pop();\n        locationHistory.pop();\n        addRoute(routeInfo);\n    };\n    const pop = (routeInfo) => {\n        const tabHistory = getTabsHistory(routeInfo.tab);\n        let ri;\n        if (tabHistory) {\n            // Pop all routes until we are back\n            ri = tabHistory[tabHistory.length - 1];\n            while (ri && ri.id !== routeInfo.id) {\n                tabHistory.pop();\n                ri = tabHistory[tabHistory.length - 1];\n            }\n            // Replace with updated route\n            tabHistory.pop();\n            tabHistory.push(routeInfo);\n        }\n        ri = locationHistory[locationHistory.length - 1];\n        while (ri && ri.id !== routeInfo.id) {\n            locationHistory.pop();\n            ri = locationHistory[locationHistory.length - 1];\n        }\n        // Replace with updated route\n        locationHistory.pop();\n        locationHistory.push(routeInfo);\n    };\n    const addRoute = (routeInfo) => {\n        const tabHistory = getTabsHistory(routeInfo.tab);\n        if (tabHistory) {\n            // If the latest routeInfo is the same (going back and forth between tabs), replace it\n            if (tabHistory[tabHistory.length - 1] && tabHistory[tabHistory.length - 1].id === routeInfo.id) {\n                tabHistory.pop();\n            }\n            tabHistory.push(routeInfo);\n        }\n        locationHistory.push(routeInfo);\n    };\n    const clearHistory = () => {\n        locationHistory.length = 0;\n        Object.keys(tabsHistory).forEach(key => {\n            tabsHistory[key] = [];\n        });\n    };\n    const getTabsHistory = (tab) => {\n        let history;\n        if (tab) {\n            history = tabsHistory[tab];\n            if (!history) {\n                history = tabsHistory[tab] = [];\n            }\n        }\n        return history;\n    };\n    const previous = () => locationHistory[locationHistory.length - 2] || current();\n    const current = () => locationHistory[locationHistory.length - 1];\n    const canGoBack = (deep = 1) => locationHistory.length > deep;\n    const getFirstRouteInfoForTab = (tab) => {\n        const tabHistory = getTabsHistory(tab);\n        if (tabHistory) {\n            return tabHistory[0];\n        }\n        return undefined;\n    };\n    const getCurrentRouteInfoForTab = (tab) => {\n        const tabHistory = getTabsHistory(tab);\n        if (tabHistory) {\n            return tabHistory[tabHistory.length - 1];\n        }\n        return undefined;\n    };\n    const findLastLocation = (routeInfo) => {\n        const routeInfos = getTabsHistory(routeInfo.tab);\n        if (routeInfos) {\n            for (let i = routeInfos.length - 2; i >= 0; i--) {\n                const ri = routeInfos[i];\n                if (ri) {\n                    if (ri.pathname === routeInfo.pushedByRoute) {\n                        return ri;\n                    }\n                }\n            }\n        }\n        for (let i = locationHistory.length - 2; i >= 0; i--) {\n            const ri = locationHistory[i];\n            if (ri) {\n                if (ri.pathname === routeInfo.pushedByRoute) {\n                    return ri;\n                }\n            }\n        }\n        return undefined;\n    };\n    return {\n        current,\n        previous,\n        add,\n        canGoBack,\n        update,\n        getFirstRouteInfoForTab,\n        getCurrentRouteInfoForTab,\n        findLastLocation\n    };\n};\n//# sourceMappingURL=locationHistory.js.map","const ids = { main: 0 };\nexport const generateId = (type = 'main') => {\n    var _a;\n    const id = ((_a = ids[type]) !== null && _a !== void 0 ? _a : 0) + 1;\n    ids[type] = id;\n    return (id).toString();\n};\n//# sourceMappingURL=utils.js.map","import { createLocationHistory } from './locationHistory';\nimport { generateId } from './utils';\nexport const createIonRouter = (opts, router) => {\n    let currentNavigationInfo = { direction: undefined, action: undefined };\n    /**\n     * Ionic Vue should only react to navigation\n     * changes once they have been confirmed and should\n     * never affect the outcome of navigation (with the\n     * exception of going back or selecting a tab).\n     * As a result, we should do our work in afterEach\n     * which is fired once navigation is confirmed\n     * and any user guards have run.\n     */\n    router.afterEach((to, _) => {\n        const { direction, action } = currentNavigationInfo;\n        /**\n         * When calling router.replace, we are not informed\n         * about the replace action in opts.history.listen\n         * but we can check to see if the latest routing action\n         * was a replace action by looking at the history state.\n         */\n        const replaceAction = history.state.replaced ? 'replace' : undefined;\n        handleHistoryChange(to, action || replaceAction, direction);\n        currentNavigationInfo = { direction: undefined, action: undefined };\n    });\n    const locationHistory = createLocationHistory();\n    let currentRouteInfo;\n    let incomingRouteParams;\n    let currentTab;\n    // TODO types\n    let historyChangeListeners = [];\n    if (typeof document !== 'undefined') {\n        document.addEventListener('ionBackButton', (ev) => {\n            ev.detail.register(0, (processNextHandler) => {\n                opts.history.go(-1);\n                processNextHandler();\n            });\n        });\n    }\n    opts.history.listen((_, _x, info) => {\n        /**\n         * history.listen only fires on certain\n         * event such as when the user clicks the\n         * browser back button. It also gives us\n         * additional information as to the type\n         * of navigation (forward, backward, etc).\n         *\n         * We can use this to better handle the\n         * `handleHistoryChange` call in\n         * router.beforeEach\n         */\n        currentNavigationInfo = {\n            action: info.type,\n            direction: info.direction === '' ? 'forward' : info.direction\n        };\n    });\n    const handleNavigateBack = (defaultHref, routerAnimation) => {\n        // todo grab default back button href from config\n        const routeInfo = locationHistory.current();\n        if (routeInfo && routeInfo.pushedByRoute) {\n            const prevInfo = locationHistory.findLastLocation(routeInfo);\n            if (prevInfo) {\n                incomingRouteParams = Object.assign(Object.assign({}, prevInfo), { routerAction: 'pop', routerDirection: 'back', routerAnimation: routerAnimation || routeInfo.routerAnimation });\n                if (routeInfo.lastPathname === routeInfo.pushedByRoute) {\n                    router.back();\n                }\n                else {\n                    router.replace(prevInfo.pathname + (prevInfo.search || ''));\n                }\n            }\n            else {\n                handleNavigate(defaultHref, 'pop', 'back');\n            }\n        }\n        else {\n            handleNavigate(defaultHref, 'pop', 'back');\n        }\n    };\n    const handleNavigate = (path, routerAction, routerDirection, routerAnimation, tab) => {\n        incomingRouteParams = {\n            routerAction,\n            routerDirection,\n            routerAnimation,\n            tab\n        };\n        if (routerAction === 'push') {\n            router.push(path);\n        }\n        else {\n            router.replace(path);\n        }\n    };\n    // TODO RouteLocationNormalized\n    const handleHistoryChange = (location, action, direction) => {\n        let leavingLocationInfo;\n        if (incomingRouteParams) {\n            if (incomingRouteParams.routerAction === 'replace') {\n                leavingLocationInfo = locationHistory.previous();\n            }\n            else {\n                leavingLocationInfo = locationHistory.current();\n            }\n        }\n        else {\n            leavingLocationInfo = locationHistory.current();\n        }\n        if (!leavingLocationInfo) {\n            leavingLocationInfo = {\n                pathname: '',\n                search: ''\n            };\n        }\n        const leavingUrl = leavingLocationInfo.pathname + leavingLocationInfo.search;\n        if (leavingUrl !== location.fullPath) {\n            if (!incomingRouteParams) {\n                if (action === 'replace') {\n                    incomingRouteParams = {\n                        routerAction: 'replace',\n                        routerDirection: 'none',\n                        tab: currentTab\n                    };\n                }\n                else if (action === 'pop') {\n                    const routeInfo = locationHistory.current();\n                    if (routeInfo && routeInfo.pushedByRoute) {\n                        const prevRouteInfo = locationHistory.findLastLocation(routeInfo);\n                        incomingRouteParams = Object.assign(Object.assign({}, prevRouteInfo), { routerAction: 'pop', routerDirection: 'back' });\n                    }\n                    else {\n                        incomingRouteParams = {\n                            routerAction: 'pop',\n                            routerDirection: 'none',\n                            tab: currentTab\n                        };\n                    }\n                }\n                if (!incomingRouteParams) {\n                    incomingRouteParams = {\n                        routerAction: 'push',\n                        routerDirection: direction || 'forward',\n                        tab: currentTab\n                    };\n                }\n            }\n            let routeInfo;\n            if (incomingRouteParams === null || incomingRouteParams === void 0 ? void 0 : incomingRouteParams.id) {\n                routeInfo = Object.assign(Object.assign({}, incomingRouteParams), { lastPathname: leavingLocationInfo.pathname });\n                locationHistory.add(routeInfo);\n            }\n            else {\n                const isPushed = incomingRouteParams.routerAction === 'push' && incomingRouteParams.routerDirection === 'forward';\n                routeInfo = Object.assign(Object.assign({ id: generateId('routeInfo') }, incomingRouteParams), { lastPathname: leavingLocationInfo.pathname, pathname: location.path, search: location.fullPath && location.fullPath.split('?')[1] || '', params: location.params && location.params });\n                if (isPushed) {\n                    routeInfo.tab = leavingLocationInfo.tab;\n                    routeInfo.pushedByRoute = (leavingLocationInfo.pathname !== '') ? leavingLocationInfo.pathname : undefined;\n                }\n                else if (routeInfo.routerAction === 'pop') {\n                    const route = locationHistory.findLastLocation(routeInfo);\n                    routeInfo.pushedByRoute = route === null || route === void 0 ? void 0 : route.pushedByRoute;\n                }\n                else if (routeInfo.routerAction === 'push' && routeInfo.tab !== leavingLocationInfo.tab) {\n                    const lastRoute = locationHistory.getCurrentRouteInfoForTab(routeInfo.tab);\n                    routeInfo.pushedByRoute = lastRoute === null || lastRoute === void 0 ? void 0 : lastRoute.pushedByRoute;\n                }\n                else if (routeInfo.routerAction === 'replace') {\n                    const currentRouteInfo = locationHistory.current();\n                    routeInfo.lastPathname = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.pathname) || routeInfo.lastPathname;\n                    routeInfo.pushedByRoute = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.pushedByRoute) || routeInfo.pushedByRoute;\n                    routeInfo.routerDirection = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.routerDirection) || routeInfo.routerDirection;\n                    routeInfo.routerAnimation = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.routerAnimation) || routeInfo.routerAnimation;\n                }\n                locationHistory.add(routeInfo);\n            }\n            currentRouteInfo = routeInfo;\n        }\n        incomingRouteParams = undefined;\n        historyChangeListeners.forEach(cb => cb(currentRouteInfo));\n    };\n    const getCurrentRouteInfo = () => currentRouteInfo;\n    const canGoBack = (deep = 1) => locationHistory.canGoBack(deep);\n    const navigate = (navigationOptions) => {\n        const { routerAnimation, routerDirection, routerLink } = navigationOptions;\n        incomingRouteParams = {\n            routerAnimation,\n            routerDirection: routerDirection || 'forward',\n            routerAction: 'push'\n        };\n        router.push(routerLink);\n    };\n    const resetTab = (tab, originalHref) => {\n        const routeInfo = locationHistory.getFirstRouteInfoForTab(tab);\n        if (routeInfo) {\n            const newRouteInfo = Object.assign({}, routeInfo);\n            newRouteInfo.pathname = originalHref;\n            incomingRouteParams = Object.assign(Object.assign({}, newRouteInfo), { routerAction: 'pop', routerDirection: 'back' });\n            router.push(newRouteInfo.pathname + (newRouteInfo.search || ''));\n        }\n    };\n    const changeTab = (tab, path) => {\n        const routeInfo = locationHistory.getCurrentRouteInfoForTab(tab);\n        const [pathname] = path.split('?');\n        if (routeInfo) {\n            const search = (routeInfo.search) ? `?${routeInfo.search}` : '';\n            incomingRouteParams = Object.assign(Object.assign({}, incomingRouteParams), { routerAction: 'push', routerDirection: 'none', tab });\n            /**\n             * When going back to a tab\n             * you just left, it's possible\n             * for the route info to be incorrect\n             * as the tab you want is not the\n             * tab you are on.\n             */\n            if (routeInfo.pathname === pathname) {\n                router.push(routeInfo.pathname + search);\n            }\n            else {\n                router.push(pathname + search);\n            }\n        }\n        else {\n            handleNavigate(pathname, 'push', 'none', undefined, tab);\n        }\n    };\n    const handleSetCurrentTab = (tab) => {\n        currentTab = tab;\n        const ri = Object.assign({}, locationHistory.current());\n        if (ri.tab !== tab) {\n            ri.tab = tab;\n            locationHistory.update(ri);\n        }\n    };\n    // TODO types\n    const registerHistoryChangeListener = (cb) => {\n        historyChangeListeners.push(cb);\n    };\n    return {\n        handleNavigateBack,\n        handleSetCurrentTab,\n        getCurrentRouteInfo,\n        canGoBack,\n        navigate,\n        resetTab,\n        changeTab,\n        registerHistoryChangeListener\n    };\n};\n//# sourceMappingURL=router.js.map","// @ts-nocheck\n// https://github.com/pillarjs/path-to-regexp\n// Included here so we do not need to add additional package.json dependency\n/**\n * Tokenize input string.\n */\nfunction lexer(str) {\n    const tokens = [];\n    let i = 0;\n    while (i < str.length) {\n        const char = str[i];\n        if (char === \"*\" || char === \"+\" || char === \"?\") {\n            tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"\\\\\") {\n            tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n            continue;\n        }\n        if (char === \"{\") {\n            tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"}\") {\n            tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \":\") {\n            let name = \"\";\n            let j = i + 1;\n            while (j < str.length) {\n                const code = str.charCodeAt(j);\n                if (\n                // `0-9`\n                (code >= 48 && code <= 57) ||\n                    // `A-Z`\n                    (code >= 65 && code <= 90) ||\n                    // `a-z`\n                    (code >= 97 && code <= 122) ||\n                    // `_`\n                    code === 95) {\n                    name += str[j++];\n                    continue;\n                }\n                break;\n            }\n            if (!name)\n                throw new TypeError(`Missing parameter name at ${i}`);\n            tokens.push({ type: \"NAME\", index: i, value: name });\n            i = j;\n            continue;\n        }\n        if (char === \"(\") {\n            let count = 1;\n            let pattern = \"\";\n            let j = i + 1;\n            if (str[j] === \"?\") {\n                throw new TypeError(`Pattern cannot start with \"?\" at ${j}`);\n            }\n            while (j < str.length) {\n                if (str[j] === \"\\\\\") {\n                    pattern += str[j++] + str[j++];\n                    continue;\n                }\n                if (str[j] === \")\") {\n                    count--;\n                    if (count === 0) {\n                        j++;\n                        break;\n                    }\n                }\n                else if (str[j] === \"(\") {\n                    count++;\n                    if (str[j + 1] !== \"?\") {\n                        throw new TypeError(`Capturing groups are not allowed at ${j}`);\n                    }\n                }\n                pattern += str[j++];\n            }\n            if (count)\n                throw new TypeError(`Unbalanced pattern at ${i}`);\n            if (!pattern)\n                throw new TypeError(`Missing pattern at ${i}`);\n            tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n            i = j;\n            continue;\n        }\n        tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n    }\n    tokens.push({ type: \"END\", index: i, value: \"\" });\n    return tokens;\n}\n/**\n * Parse a string for the raw tokens.\n */\nexport function parse(str, options = {}) {\n    const tokens = lexer(str);\n    const { prefixes = \"./\" } = options;\n    const defaultPattern = `[^${escapeString(options.delimiter || \"/#?\")}]+?`;\n    const result = [];\n    let key = 0;\n    let i = 0;\n    let path = \"\";\n    const tryConsume = (type) => {\n        if (i < tokens.length && tokens[i].type === type)\n            return tokens[i++].value;\n    };\n    const mustConsume = (type) => {\n        const value = tryConsume(type);\n        if (value !== undefined)\n            return value;\n        const { type: nextType, index } = tokens[i];\n        throw new TypeError(`Unexpected ${nextType} at ${index}, expected ${type}`);\n    };\n    const consumeText = () => {\n        let result = \"\";\n        let value;\n        // tslint:disable-next-line\n        while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n            result += value;\n        }\n        return result;\n    };\n    while (i < tokens.length) {\n        const char = tryConsume(\"CHAR\");\n        const name = tryConsume(\"NAME\");\n        const pattern = tryConsume(\"PATTERN\");\n        if (name || pattern) {\n            let prefix = char || \"\";\n            if (prefixes.indexOf(prefix) === -1) {\n                path += prefix;\n                prefix = \"\";\n            }\n            if (path) {\n                result.push(path);\n                path = \"\";\n            }\n            result.push({\n                name: name || key++,\n                prefix,\n                suffix: \"\",\n                pattern: pattern || defaultPattern,\n                modifier: tryConsume(\"MODIFIER\") || \"\"\n            });\n            continue;\n        }\n        const value = char || tryConsume(\"ESCAPED_CHAR\");\n        if (value) {\n            path += value;\n            continue;\n        }\n        if (path) {\n            result.push(path);\n            path = \"\";\n        }\n        const open = tryConsume(\"OPEN\");\n        if (open) {\n            const prefix = consumeText();\n            const name = tryConsume(\"NAME\") || \"\";\n            const pattern = tryConsume(\"PATTERN\") || \"\";\n            const suffix = consumeText();\n            mustConsume(\"CLOSE\");\n            result.push({\n                name: name || (pattern ? key++ : \"\"),\n                pattern: name && !pattern ? defaultPattern : pattern,\n                prefix,\n                suffix,\n                modifier: tryConsume(\"MODIFIER\") || \"\"\n            });\n            continue;\n        }\n        mustConsume(\"END\");\n    }\n    return result;\n}\n/**\n * Compile a string to a template function for the path.\n */\nexport function compile(str, options) {\n    return tokensToFunction(parse(str, options), options);\n}\n/**\n * Expose a method for transforming tokens into the path function.\n */\nexport function tokensToFunction(tokens, options = {}) {\n    const reFlags = flags(options);\n    const { encode = (x) => x, validate = true } = options;\n    // Compile all the tokens into regexps.\n    const matches = tokens.map(token => {\n        if (typeof token === \"object\") {\n            return new RegExp(`^(?:${token.pattern})$`, reFlags);\n        }\n    });\n    return (data) => {\n        let path = \"\";\n        for (let i = 0; i < tokens.length; i++) {\n            const token = tokens[i];\n            if (typeof token === \"string\") {\n                path += token;\n                continue;\n            }\n            const value = data ? data[token.name] : undefined;\n            const optional = token.modifier === \"?\" || token.modifier === \"*\";\n            const repeat = token.modifier === \"*\" || token.modifier === \"+\";\n            if (Array.isArray(value)) {\n                if (!repeat) {\n                    throw new TypeError(`Expected \"${token.name}\" to not repeat, but got an array`);\n                }\n                if (value.length === 0) {\n                    if (optional)\n                        continue;\n                    throw new TypeError(`Expected \"${token.name}\" to not be empty`);\n                }\n                for (let j = 0; j < value.length; j++) {\n                    const segment = encode(value[j], token);\n                    if (validate && !matches[i].test(segment)) {\n                        throw new TypeError(`Expected all \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`);\n                    }\n                    path += token.prefix + segment + token.suffix;\n                }\n                continue;\n            }\n            if (typeof value === \"string\" || typeof value === \"number\") {\n                const segment = encode(String(value), token);\n                if (validate && !matches[i].test(segment)) {\n                    throw new TypeError(`Expected \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`);\n                }\n                path += token.prefix + segment + token.suffix;\n                continue;\n            }\n            if (optional)\n                continue;\n            const typeOfMessage = repeat ? \"an array\" : \"a string\";\n            throw new TypeError(`Expected \"${token.name}\" to be ${typeOfMessage}`);\n        }\n        return path;\n    };\n}\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nexport function match(str, options) {\n    const keys = [];\n    const re = pathToRegexp(str, keys, options);\n    return regexpToFunction(re, keys, options);\n}\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nexport function regexpToFunction(re, keys, options = {}) {\n    const { decode = (x) => x } = options;\n    return function (pathname) {\n        const m = re.exec(pathname);\n        if (!m)\n            return false;\n        const { 0: path, index } = m;\n        const params = Object.create(null);\n        for (let i = 1; i < m.length; i++) {\n            // tslint:disable-next-line\n            if (m[i] === undefined)\n                continue;\n            const key = keys[i - 1];\n            if (key.modifier === \"*\" || key.modifier === \"+\") {\n                params[key.name] = m[i].split(key.prefix + key.suffix).map(value => {\n                    return decode(value, key);\n                });\n            }\n            else {\n                params[key.name] = decode(m[i], key);\n            }\n        }\n        return { path, index, params };\n    };\n}\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str) {\n    return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options) {\n    return options && options.sensitive ? \"\" : \"i\";\n}\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path, keys) {\n    if (!keys)\n        return path;\n    const groupsRegex = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\n    let index = 0;\n    let execResult = groupsRegex.exec(path.source);\n    while (execResult) {\n        keys.push({\n            // Use parenthesized substring match if available, index otherwise\n            name: execResult[1] || index++,\n            prefix: \"\",\n            suffix: \"\",\n            modifier: \"\",\n            pattern: \"\"\n        });\n        execResult = groupsRegex.exec(path.source);\n    }\n    return path;\n}\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(paths, keys, options) {\n    const parts = paths.map(path => pathToRegexp(path, keys, options).source);\n    return new RegExp(`(?:${parts.join(\"|\")})`, flags(options));\n}\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(path, keys, options) {\n    return tokensToRegexp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nexport function tokensToRegexp(tokens, keys, options = {}) {\n    const { strict = false, start = true, end = true, encode = (x) => x } = options;\n    const endsWith = `[${escapeString(options.endsWith || \"\")}]|$`;\n    const delimiter = `[${escapeString(options.delimiter || \"/#?\")}]`;\n    let route = start ? \"^\" : \"\";\n    // Iterate over the tokens and create our regexp string.\n    for (const token of tokens) {\n        if (typeof token === \"string\") {\n            route += escapeString(encode(token));\n        }\n        else {\n            const prefix = escapeString(encode(token.prefix));\n            const suffix = escapeString(encode(token.suffix));\n            if (token.pattern) {\n                if (keys)\n                    keys.push(token);\n                if (prefix || suffix) {\n                    if (token.modifier === \"+\" || token.modifier === \"*\") {\n                        const mod = token.modifier === \"*\" ? \"?\" : \"\";\n                        route += `(?:${prefix}((?:${token.pattern})(?:${suffix}${prefix}(?:${token.pattern}))*)${suffix})${mod}`;\n                    }\n                    else {\n                        route += `(?:${prefix}(${token.pattern})${suffix})${token.modifier}`;\n                    }\n                }\n                else {\n                    route += `(${token.pattern})${token.modifier}`;\n                }\n            }\n            else {\n                route += `(?:${prefix}${suffix})${token.modifier}`;\n            }\n        }\n    }\n    if (end) {\n        if (!strict)\n            route += `${delimiter}?`;\n        route += !options.endsWith ? \"$\" : `(?=${endsWith})`;\n    }\n    else {\n        const endToken = tokens[tokens.length - 1];\n        const isEndDelimited = typeof endToken === \"string\"\n            ? delimiter.indexOf(endToken[endToken.length - 1]) > -1\n            : // tslint:disable-next-line\n                endToken === undefined;\n        if (!strict) {\n            route += `(?:${delimiter}(?=${endsWith}))?`;\n        }\n        if (!isEndDelimited) {\n            route += `(?=${delimiter}|${endsWith})`;\n        }\n    }\n    return new RegExp(route, flags(options));\n}\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nexport function pathToRegexp(path, keys, options) {\n    if (path instanceof RegExp)\n        return regexpToRegexp(path, keys);\n    if (Array.isArray(path))\n        return arrayToRegexp(path, keys, options);\n    return stringToRegexp(path, keys, options);\n}\n//# sourceMappingURL=regexp.js.map","import { generateId } from './utils';\nimport { pathToRegexp } from './regexp';\nimport { shallowRef } from 'vue';\nexport const createViewStacks = () => {\n    let viewStacks = {};\n    const clear = (outletId) => {\n        delete viewStacks[outletId];\n    };\n    const getViewStack = (outletId) => {\n        return viewStacks[outletId];\n    };\n    const registerIonPage = (viewItem, ionPage) => {\n        viewItem.ionPageElement = ionPage;\n    };\n    const findViewItemByRouteInfo = (routeInfo, outletId) => {\n        return findViewItemByPath(routeInfo.pathname, outletId);\n    };\n    const findLeavingViewItemByRouteInfo = (routeInfo, outletId) => {\n        return findViewItemByPath(routeInfo.lastPathname, outletId, false);\n    };\n    const findViewItemInStack = (path, stack) => {\n        return stack.find((viewItem) => {\n            if (viewItem.pathname === path) {\n                return viewItem;\n            }\n            return undefined;\n        });\n    };\n    const findViewItemByPath = (path, outletId, strict = true) => {\n        const matchView = (viewItem) => {\n            const pathname = path;\n            const viewItemPath = viewItem.matchedRoute.path;\n            const regexp = pathToRegexp(viewItemPath, [], {\n                end: viewItem.exact,\n                strict: viewItem.exact,\n                sensitive: false\n            });\n            return (regexp.exec(pathname)) ? viewItem : undefined;\n        };\n        if (outletId) {\n            const stack = viewStacks[outletId];\n            if (!stack)\n                return undefined;\n            const quickMatch = findViewItemInStack(path, stack);\n            if (quickMatch)\n                return quickMatch;\n            if (!strict) {\n                const match = stack.find(matchView);\n                if (match)\n                    return match;\n            }\n        }\n        else {\n            for (let outletId in viewStacks) {\n                const stack = viewStacks[outletId];\n                const viewItem = findViewItemInStack(path, stack);\n                if (viewItem) {\n                    return viewItem;\n                }\n            }\n        }\n        return undefined;\n    };\n    const createViewItem = (outletId, vueComponent, matchedRoute, routeInfo, ionPage) => {\n        return {\n            id: generateId('viewItem'),\n            pathname: routeInfo.pathname,\n            outletId,\n            matchedRoute,\n            ionPageElement: ionPage,\n            vueComponent,\n            vueComponentRef: shallowRef(),\n            ionRoute: false,\n            mount: false,\n            exact: routeInfo.pathname === matchedRoute.path\n        };\n    };\n    const add = (viewItem) => {\n        const { outletId } = viewItem;\n        if (!viewStacks[outletId]) {\n            viewStacks[outletId] = [viewItem];\n        }\n        else {\n            viewStacks[outletId].push(viewItem);\n        }\n    };\n    const remove = (viewItem, outletId) => {\n        if (!outletId) {\n            throw Error('outletId required');\n        }\n        const viewStack = viewStacks[outletId];\n        if (viewStack) {\n            viewStacks[outletId] = viewStack.filter(item => item.id !== viewItem.id);\n        }\n    };\n    const getChildrenToRender = (outletId) => {\n        const viewStack = viewStacks[outletId];\n        if (viewStack) {\n            const components = viewStacks[outletId].filter(v => v.mount);\n            return components;\n        }\n        return [];\n    };\n    return {\n        clear,\n        findViewItemByRouteInfo,\n        findLeavingViewItemByRouteInfo,\n        createViewItem,\n        getChildrenToRender,\n        add,\n        remove,\n        registerIonPage,\n        getViewStack\n    };\n};\n//# sourceMappingURL=viewStacks.js.map","import { createRouter as createVueRouter, createWebHistory as createVueWebHistory, createWebHashHistory as createVueWebHashHistory, createMemoryHistory as createVueMemoryHistory } from 'vue-router';\nimport { createIonRouter } from './router';\nimport { createViewStacks } from './viewStacks';\nexport const createRouter = (opts) => {\n    const routerOptions = Object.assign({}, opts);\n    delete routerOptions.tabsPrefix;\n    const router = createVueRouter(routerOptions);\n    const ionRouter = createIonRouter(opts, router);\n    const viewStacks = createViewStacks();\n    const oldInstall = router.install.bind(router);\n    router.install = (app) => {\n        app.provide('navManager', ionRouter);\n        app.provide('viewStacks', viewStacks);\n        oldInstall(app);\n    };\n    const oldIsReady = router.isReady.bind(router);\n    router.isReady = () => oldIsReady();\n    return router;\n};\nexport const createWebHistory = (base) => createVueWebHistory(base);\nexport const createWebHashHistory = (base) => createVueWebHashHistory(base);\nexport const createMemoryHistory = (base) => createVueMemoryHistory(base);\n//# sourceMappingURL=index.js.map"],"names":["createVueRouter","createVueWebHistory","createVueWebHashHistory","createVueMemoryHistory"],"mappings":"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"}
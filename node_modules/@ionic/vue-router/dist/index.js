import { createRouter as createRouter$1, createWebHistory as createWebHistory$1, createWebHashHistory as createWebHashHistory$1, createMemoryHistory as createMemoryHistory$1 } from 'vue-router';
import { shallowRef } from 'vue';

const createLocationHistory = () => {
    const locationHistory = [];
    const tabsHistory = {};
    const add = (routeInfo) => {
        switch (routeInfo.routerAction) {
            case "replace":
                replaceRoute(routeInfo);
                break;
            case "pop":
                pop(routeInfo);
                break;
            default:
                addRoute(routeInfo);
                break;
        }
        if (routeInfo.routerDirection === 'root') {
            clearHistory();
            addRoute(routeInfo);
        }
    };
    const update = (routeInfo) => {
        const locationIndex = locationHistory.findIndex(x => x.id === routeInfo.id);
        if (locationIndex > -1) {
            locationHistory.splice(locationIndex, 1, routeInfo);
        }
        const tabArray = tabsHistory[routeInfo.tab || ''];
        if (tabArray) {
            const tabIndex = tabArray.findIndex(x => x.id === routeInfo.id);
            if (tabIndex > -1) {
                tabArray.splice(tabIndex, 1, routeInfo);
            }
            else {
                tabArray.push(routeInfo);
            }
        }
        else if (routeInfo.tab) {
            tabsHistory[routeInfo.tab] = [routeInfo];
        }
    };
    const replaceRoute = (routeInfo) => {
        const routeInfos = getTabsHistory(routeInfo.tab);
        routeInfos && routeInfos.pop();
        locationHistory.pop();
        addRoute(routeInfo);
    };
    const pop = (routeInfo) => {
        const tabHistory = getTabsHistory(routeInfo.tab);
        let ri;
        if (tabHistory) {
            // Pop all routes until we are back
            ri = tabHistory[tabHistory.length - 1];
            while (ri && ri.id !== routeInfo.id) {
                tabHistory.pop();
                ri = tabHistory[tabHistory.length - 1];
            }
            // Replace with updated route
            tabHistory.pop();
            tabHistory.push(routeInfo);
        }
        ri = locationHistory[locationHistory.length - 1];
        while (ri && ri.id !== routeInfo.id) {
            locationHistory.pop();
            ri = locationHistory[locationHistory.length - 1];
        }
        // Replace with updated route
        locationHistory.pop();
        locationHistory.push(routeInfo);
    };
    const addRoute = (routeInfo) => {
        const tabHistory = getTabsHistory(routeInfo.tab);
        if (tabHistory) {
            // If the latest routeInfo is the same (going back and forth between tabs), replace it
            if (tabHistory[tabHistory.length - 1] && tabHistory[tabHistory.length - 1].id === routeInfo.id) {
                tabHistory.pop();
            }
            tabHistory.push(routeInfo);
        }
        locationHistory.push(routeInfo);
    };
    const clearHistory = () => {
        locationHistory.length = 0;
        Object.keys(tabsHistory).forEach(key => {
            tabsHistory[key] = [];
        });
    };
    const getTabsHistory = (tab) => {
        let history;
        if (tab) {
            history = tabsHistory[tab];
            if (!history) {
                history = tabsHistory[tab] = [];
            }
        }
        return history;
    };
    const previous = () => locationHistory[locationHistory.length - 2] || current();
    const current = () => locationHistory[locationHistory.length - 1];
    const canGoBack = (deep = 1) => locationHistory.length > deep;
    const getFirstRouteInfoForTab = (tab) => {
        const tabHistory = getTabsHistory(tab);
        if (tabHistory) {
            return tabHistory[0];
        }
        return undefined;
    };
    const getCurrentRouteInfoForTab = (tab) => {
        const tabHistory = getTabsHistory(tab);
        if (tabHistory) {
            return tabHistory[tabHistory.length - 1];
        }
        return undefined;
    };
    const findLastLocation = (routeInfo) => {
        const routeInfos = getTabsHistory(routeInfo.tab);
        if (routeInfos) {
            for (let i = routeInfos.length - 2; i >= 0; i--) {
                const ri = routeInfos[i];
                if (ri) {
                    if (ri.pathname === routeInfo.pushedByRoute) {
                        return ri;
                    }
                }
            }
        }
        for (let i = locationHistory.length - 2; i >= 0; i--) {
            const ri = locationHistory[i];
            if (ri) {
                if (ri.pathname === routeInfo.pushedByRoute) {
                    return ri;
                }
            }
        }
        return undefined;
    };
    return {
        current,
        previous,
        add,
        canGoBack,
        update,
        getFirstRouteInfoForTab,
        getCurrentRouteInfoForTab,
        findLastLocation
    };
};

const ids = { main: 0 };
const generateId = (type = 'main') => {
    var _a;
    const id = ((_a = ids[type]) !== null && _a !== void 0 ? _a : 0) + 1;
    ids[type] = id;
    return (id).toString();
};

const createIonRouter = (opts, router) => {
    let currentNavigationInfo = { direction: undefined, action: undefined };
    /**
     * Ionic Vue should only react to navigation
     * changes once they have been confirmed and should
     * never affect the outcome of navigation (with the
     * exception of going back or selecting a tab).
     * As a result, we should do our work in afterEach
     * which is fired once navigation is confirmed
     * and any user guards have run.
     */
    router.afterEach((to, _) => {
        const { direction, action } = currentNavigationInfo;
        /**
         * When calling router.replace, we are not informed
         * about the replace action in opts.history.listen
         * but we can check to see if the latest routing action
         * was a replace action by looking at the history state.
         */
        const replaceAction = history.state.replaced ? 'replace' : undefined;
        handleHistoryChange(to, action || replaceAction, direction);
        currentNavigationInfo = { direction: undefined, action: undefined };
    });
    const locationHistory = createLocationHistory();
    let currentRouteInfo;
    let incomingRouteParams;
    let currentTab;
    // TODO types
    let historyChangeListeners = [];
    if (typeof document !== 'undefined') {
        document.addEventListener('ionBackButton', (ev) => {
            ev.detail.register(0, (processNextHandler) => {
                opts.history.go(-1);
                processNextHandler();
            });
        });
    }
    opts.history.listen((_, _x, info) => {
        /**
         * history.listen only fires on certain
         * event such as when the user clicks the
         * browser back button. It also gives us
         * additional information as to the type
         * of navigation (forward, backward, etc).
         *
         * We can use this to better handle the
         * `handleHistoryChange` call in
         * router.beforeEach
         */
        currentNavigationInfo = {
            action: info.type,
            direction: info.direction === '' ? 'forward' : info.direction
        };
    });
    const handleNavigateBack = (defaultHref, routerAnimation) => {
        // todo grab default back button href from config
        const routeInfo = locationHistory.current();
        if (routeInfo && routeInfo.pushedByRoute) {
            const prevInfo = locationHistory.findLastLocation(routeInfo);
            if (prevInfo) {
                incomingRouteParams = Object.assign(Object.assign({}, prevInfo), { routerAction: 'pop', routerDirection: 'back', routerAnimation: routerAnimation || routeInfo.routerAnimation });
                if (routeInfo.lastPathname === routeInfo.pushedByRoute) {
                    router.back();
                }
                else {
                    router.replace(prevInfo.pathname + (prevInfo.search || ''));
                }
            }
            else {
                handleNavigate(defaultHref, 'pop', 'back');
            }
        }
        else {
            handleNavigate(defaultHref, 'pop', 'back');
        }
    };
    const handleNavigate = (path, routerAction, routerDirection, routerAnimation, tab) => {
        incomingRouteParams = {
            routerAction,
            routerDirection,
            routerAnimation,
            tab
        };
        if (routerAction === 'push') {
            router.push(path);
        }
        else {
            router.replace(path);
        }
    };
    // TODO RouteLocationNormalized
    const handleHistoryChange = (location, action, direction) => {
        let leavingLocationInfo;
        if (incomingRouteParams) {
            if (incomingRouteParams.routerAction === 'replace') {
                leavingLocationInfo = locationHistory.previous();
            }
            else {
                leavingLocationInfo = locationHistory.current();
            }
        }
        else {
            leavingLocationInfo = locationHistory.current();
        }
        if (!leavingLocationInfo) {
            leavingLocationInfo = {
                pathname: '',
                search: ''
            };
        }
        const leavingUrl = leavingLocationInfo.pathname + leavingLocationInfo.search;
        if (leavingUrl !== location.fullPath) {
            if (!incomingRouteParams) {
                if (action === 'replace') {
                    incomingRouteParams = {
                        routerAction: 'replace',
                        routerDirection: 'none',
                        tab: currentTab
                    };
                }
                else if (action === 'pop') {
                    const routeInfo = locationHistory.current();
                    if (routeInfo && routeInfo.pushedByRoute) {
                        const prevRouteInfo = locationHistory.findLastLocation(routeInfo);
                        incomingRouteParams = Object.assign(Object.assign({}, prevRouteInfo), { routerAction: 'pop', routerDirection: 'back' });
                    }
                    else {
                        incomingRouteParams = {
                            routerAction: 'pop',
                            routerDirection: 'none',
                            tab: currentTab
                        };
                    }
                }
                if (!incomingRouteParams) {
                    incomingRouteParams = {
                        routerAction: 'push',
                        routerDirection: direction || 'forward',
                        tab: currentTab
                    };
                }
            }
            let routeInfo;
            if (incomingRouteParams === null || incomingRouteParams === void 0 ? void 0 : incomingRouteParams.id) {
                routeInfo = Object.assign(Object.assign({}, incomingRouteParams), { lastPathname: leavingLocationInfo.pathname });
                locationHistory.add(routeInfo);
            }
            else {
                const isPushed = incomingRouteParams.routerAction === 'push' && incomingRouteParams.routerDirection === 'forward';
                routeInfo = Object.assign(Object.assign({ id: generateId('routeInfo') }, incomingRouteParams), { lastPathname: leavingLocationInfo.pathname, pathname: location.path, search: location.fullPath && location.fullPath.split('?')[1] || '', params: location.params && location.params });
                if (isPushed) {
                    routeInfo.tab = leavingLocationInfo.tab;
                    routeInfo.pushedByRoute = (leavingLocationInfo.pathname !== '') ? leavingLocationInfo.pathname : undefined;
                }
                else if (routeInfo.routerAction === 'pop') {
                    const route = locationHistory.findLastLocation(routeInfo);
                    routeInfo.pushedByRoute = route === null || route === void 0 ? void 0 : route.pushedByRoute;
                }
                else if (routeInfo.routerAction === 'push' && routeInfo.tab !== leavingLocationInfo.tab) {
                    const lastRoute = locationHistory.getCurrentRouteInfoForTab(routeInfo.tab);
                    routeInfo.pushedByRoute = lastRoute === null || lastRoute === void 0 ? void 0 : lastRoute.pushedByRoute;
                }
                else if (routeInfo.routerAction === 'replace') {
                    const currentRouteInfo = locationHistory.current();
                    routeInfo.lastPathname = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.pathname) || routeInfo.lastPathname;
                    routeInfo.pushedByRoute = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.pushedByRoute) || routeInfo.pushedByRoute;
                    routeInfo.routerDirection = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.routerDirection) || routeInfo.routerDirection;
                    routeInfo.routerAnimation = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.routerAnimation) || routeInfo.routerAnimation;
                }
                locationHistory.add(routeInfo);
            }
            currentRouteInfo = routeInfo;
        }
        incomingRouteParams = undefined;
        historyChangeListeners.forEach(cb => cb(currentRouteInfo));
    };
    const getCurrentRouteInfo = () => currentRouteInfo;
    const canGoBack = (deep = 1) => locationHistory.canGoBack(deep);
    const navigate = (navigationOptions) => {
        const { routerAnimation, routerDirection, routerLink } = navigationOptions;
        incomingRouteParams = {
            routerAnimation,
            routerDirection: routerDirection || 'forward',
            routerAction: 'push'
        };
        router.push(routerLink);
    };
    const resetTab = (tab, originalHref) => {
        const routeInfo = locationHistory.getFirstRouteInfoForTab(tab);
        if (routeInfo) {
            const newRouteInfo = Object.assign({}, routeInfo);
            newRouteInfo.pathname = originalHref;
            incomingRouteParams = Object.assign(Object.assign({}, newRouteInfo), { routerAction: 'pop', routerDirection: 'back' });
            router.push(newRouteInfo.pathname + (newRouteInfo.search || ''));
        }
    };
    const changeTab = (tab, path) => {
        const routeInfo = locationHistory.getCurrentRouteInfoForTab(tab);
        const [pathname] = path.split('?');
        if (routeInfo) {
            const search = (routeInfo.search) ? `?${routeInfo.search}` : '';
            incomingRouteParams = Object.assign(Object.assign({}, incomingRouteParams), { routerAction: 'push', routerDirection: 'none', tab });
            /**
             * When going back to a tab
             * you just left, it's possible
             * for the route info to be incorrect
             * as the tab you want is not the
             * tab you are on.
             */
            if (routeInfo.pathname === pathname) {
                router.push(routeInfo.pathname + search);
            }
            else {
                router.push(pathname + search);
            }
        }
        else {
            handleNavigate(pathname, 'push', 'none', undefined, tab);
        }
    };
    const handleSetCurrentTab = (tab) => {
        currentTab = tab;
        const ri = Object.assign({}, locationHistory.current());
        if (ri.tab !== tab) {
            ri.tab = tab;
            locationHistory.update(ri);
        }
    };
    // TODO types
    const registerHistoryChangeListener = (cb) => {
        historyChangeListeners.push(cb);
    };
    return {
        handleNavigateBack,
        handleSetCurrentTab,
        getCurrentRouteInfo,
        canGoBack,
        navigate,
        resetTab,
        changeTab,
        registerHistoryChangeListener
    };
};

// @ts-nocheck
// https://github.com/pillarjs/path-to-regexp
// Included here so we do not need to add additional package.json dependency
/**
 * Tokenize input string.
 */
function lexer(str) {
    const tokens = [];
    let i = 0;
    while (i < str.length) {
        const char = str[i];
        if (char === "*" || char === "+" || char === "?") {
            tokens.push({ type: "MODIFIER", index: i, value: str[i++] });
            continue;
        }
        if (char === "\\") {
            tokens.push({ type: "ESCAPED_CHAR", index: i++, value: str[i++] });
            continue;
        }
        if (char === "{") {
            tokens.push({ type: "OPEN", index: i, value: str[i++] });
            continue;
        }
        if (char === "}") {
            tokens.push({ type: "CLOSE", index: i, value: str[i++] });
            continue;
        }
        if (char === ":") {
            let name = "";
            let j = i + 1;
            while (j < str.length) {
                const code = str.charCodeAt(j);
                if (
                // `0-9`
                (code >= 48 && code <= 57) ||
                    // `A-Z`
                    (code >= 65 && code <= 90) ||
                    // `a-z`
                    (code >= 97 && code <= 122) ||
                    // `_`
                    code === 95) {
                    name += str[j++];
                    continue;
                }
                break;
            }
            if (!name)
                throw new TypeError(`Missing parameter name at ${i}`);
            tokens.push({ type: "NAME", index: i, value: name });
            i = j;
            continue;
        }
        if (char === "(") {
            let count = 1;
            let pattern = "";
            let j = i + 1;
            if (str[j] === "?") {
                throw new TypeError(`Pattern cannot start with "?" at ${j}`);
            }
            while (j < str.length) {
                if (str[j] === "\\") {
                    pattern += str[j++] + str[j++];
                    continue;
                }
                if (str[j] === ")") {
                    count--;
                    if (count === 0) {
                        j++;
                        break;
                    }
                }
                else if (str[j] === "(") {
                    count++;
                    if (str[j + 1] !== "?") {
                        throw new TypeError(`Capturing groups are not allowed at ${j}`);
                    }
                }
                pattern += str[j++];
            }
            if (count)
                throw new TypeError(`Unbalanced pattern at ${i}`);
            if (!pattern)
                throw new TypeError(`Missing pattern at ${i}`);
            tokens.push({ type: "PATTERN", index: i, value: pattern });
            i = j;
            continue;
        }
        tokens.push({ type: "CHAR", index: i, value: str[i++] });
    }
    tokens.push({ type: "END", index: i, value: "" });
    return tokens;
}
/**
 * Parse a string for the raw tokens.
 */
function parse(str, options = {}) {
    const tokens = lexer(str);
    const { prefixes = "./" } = options;
    const defaultPattern = `[^${escapeString(options.delimiter || "/#?")}]+?`;
    const result = [];
    let key = 0;
    let i = 0;
    let path = "";
    const tryConsume = (type) => {
        if (i < tokens.length && tokens[i].type === type)
            return tokens[i++].value;
    };
    const mustConsume = (type) => {
        const value = tryConsume(type);
        if (value !== undefined)
            return value;
        const { type: nextType, index } = tokens[i];
        throw new TypeError(`Unexpected ${nextType} at ${index}, expected ${type}`);
    };
    const consumeText = () => {
        let result = "";
        let value;
        // tslint:disable-next-line
        while ((value = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR"))) {
            result += value;
        }
        return result;
    };
    while (i < tokens.length) {
        const char = tryConsume("CHAR");
        const name = tryConsume("NAME");
        const pattern = tryConsume("PATTERN");
        if (name || pattern) {
            let prefix = char || "";
            if (prefixes.indexOf(prefix) === -1) {
                path += prefix;
                prefix = "";
            }
            if (path) {
                result.push(path);
                path = "";
            }
            result.push({
                name: name || key++,
                prefix,
                suffix: "",
                pattern: pattern || defaultPattern,
                modifier: tryConsume("MODIFIER") || ""
            });
            continue;
        }
        const value = char || tryConsume("ESCAPED_CHAR");
        if (value) {
            path += value;
            continue;
        }
        if (path) {
            result.push(path);
            path = "";
        }
        const open = tryConsume("OPEN");
        if (open) {
            const prefix = consumeText();
            const name = tryConsume("NAME") || "";
            const pattern = tryConsume("PATTERN") || "";
            const suffix = consumeText();
            mustConsume("CLOSE");
            result.push({
                name: name || (pattern ? key++ : ""),
                pattern: name && !pattern ? defaultPattern : pattern,
                prefix,
                suffix,
                modifier: tryConsume("MODIFIER") || ""
            });
            continue;
        }
        mustConsume("END");
    }
    return result;
}
/**
 * Escape a regular expression string.
 */
function escapeString(str) {
    return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
}
/**
 * Get the flags for a regexp from the options.
 */
function flags(options) {
    return options && options.sensitive ? "" : "i";
}
/**
 * Pull out keys from a regexp.
 */
function regexpToRegexp(path, keys) {
    if (!keys)
        return path;
    const groupsRegex = /\((?:\?<(.*?)>)?(?!\?)/g;
    let index = 0;
    let execResult = groupsRegex.exec(path.source);
    while (execResult) {
        keys.push({
            // Use parenthesized substring match if available, index otherwise
            name: execResult[1] || index++,
            prefix: "",
            suffix: "",
            modifier: "",
            pattern: ""
        });
        execResult = groupsRegex.exec(path.source);
    }
    return path;
}
/**
 * Transform an array into a regexp.
 */
function arrayToRegexp(paths, keys, options) {
    const parts = paths.map(path => pathToRegexp(path, keys, options).source);
    return new RegExp(`(?:${parts.join("|")})`, flags(options));
}
/**
 * Create a path regexp from string input.
 */
function stringToRegexp(path, keys, options) {
    return tokensToRegexp(parse(path, options), keys, options);
}
/**
 * Expose a function for taking tokens and returning a RegExp.
 */
function tokensToRegexp(tokens, keys, options = {}) {
    const { strict = false, start = true, end = true, encode = (x) => x } = options;
    const endsWith = `[${escapeString(options.endsWith || "")}]|$`;
    const delimiter = `[${escapeString(options.delimiter || "/#?")}]`;
    let route = start ? "^" : "";
    // Iterate over the tokens and create our regexp string.
    for (const token of tokens) {
        if (typeof token === "string") {
            route += escapeString(encode(token));
        }
        else {
            const prefix = escapeString(encode(token.prefix));
            const suffix = escapeString(encode(token.suffix));
            if (token.pattern) {
                if (keys)
                    keys.push(token);
                if (prefix || suffix) {
                    if (token.modifier === "+" || token.modifier === "*") {
                        const mod = token.modifier === "*" ? "?" : "";
                        route += `(?:${prefix}((?:${token.pattern})(?:${suffix}${prefix}(?:${token.pattern}))*)${suffix})${mod}`;
                    }
                    else {
                        route += `(?:${prefix}(${token.pattern})${suffix})${token.modifier}`;
                    }
                }
                else {
                    route += `(${token.pattern})${token.modifier}`;
                }
            }
            else {
                route += `(?:${prefix}${suffix})${token.modifier}`;
            }
        }
    }
    if (end) {
        if (!strict)
            route += `${delimiter}?`;
        route += !options.endsWith ? "$" : `(?=${endsWith})`;
    }
    else {
        const endToken = tokens[tokens.length - 1];
        const isEndDelimited = typeof endToken === "string"
            ? delimiter.indexOf(endToken[endToken.length - 1]) > -1
            : // tslint:disable-next-line
                endToken === undefined;
        if (!strict) {
            route += `(?:${delimiter}(?=${endsWith}))?`;
        }
        if (!isEndDelimited) {
            route += `(?=${delimiter}|${endsWith})`;
        }
    }
    return new RegExp(route, flags(options));
}
/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 */
function pathToRegexp(path, keys, options) {
    if (path instanceof RegExp)
        return regexpToRegexp(path, keys);
    if (Array.isArray(path))
        return arrayToRegexp(path, keys, options);
    return stringToRegexp(path, keys, options);
}

const createViewStacks = () => {
    let viewStacks = {};
    const clear = (outletId) => {
        delete viewStacks[outletId];
    };
    const getViewStack = (outletId) => {
        return viewStacks[outletId];
    };
    const registerIonPage = (viewItem, ionPage) => {
        viewItem.ionPageElement = ionPage;
    };
    const findViewItemByRouteInfo = (routeInfo, outletId) => {
        return findViewItemByPath(routeInfo.pathname, outletId);
    };
    const findLeavingViewItemByRouteInfo = (routeInfo, outletId) => {
        return findViewItemByPath(routeInfo.lastPathname, outletId, false);
    };
    const findViewItemInStack = (path, stack) => {
        return stack.find((viewItem) => {
            if (viewItem.pathname === path) {
                return viewItem;
            }
            return undefined;
        });
    };
    const findViewItemByPath = (path, outletId, strict = true) => {
        const matchView = (viewItem) => {
            const pathname = path;
            const viewItemPath = viewItem.matchedRoute.path;
            const regexp = pathToRegexp(viewItemPath, [], {
                end: viewItem.exact,
                strict: viewItem.exact,
                sensitive: false
            });
            return (regexp.exec(pathname)) ? viewItem : undefined;
        };
        if (outletId) {
            const stack = viewStacks[outletId];
            if (!stack)
                return undefined;
            const quickMatch = findViewItemInStack(path, stack);
            if (quickMatch)
                return quickMatch;
            if (!strict) {
                const match = stack.find(matchView);
                if (match)
                    return match;
            }
        }
        else {
            for (let outletId in viewStacks) {
                const stack = viewStacks[outletId];
                const viewItem = findViewItemInStack(path, stack);
                if (viewItem) {
                    return viewItem;
                }
            }
        }
        return undefined;
    };
    const createViewItem = (outletId, vueComponent, matchedRoute, routeInfo, ionPage) => {
        return {
            id: generateId('viewItem'),
            pathname: routeInfo.pathname,
            outletId,
            matchedRoute,
            ionPageElement: ionPage,
            vueComponent,
            vueComponentRef: shallowRef(),
            ionRoute: false,
            mount: false,
            exact: routeInfo.pathname === matchedRoute.path
        };
    };
    const add = (viewItem) => {
        const { outletId } = viewItem;
        if (!viewStacks[outletId]) {
            viewStacks[outletId] = [viewItem];
        }
        else {
            viewStacks[outletId].push(viewItem);
        }
    };
    const remove = (viewItem, outletId) => {
        if (!outletId) {
            throw Error('outletId required');
        }
        const viewStack = viewStacks[outletId];
        if (viewStack) {
            viewStacks[outletId] = viewStack.filter(item => item.id !== viewItem.id);
        }
    };
    const getChildrenToRender = (outletId) => {
        const viewStack = viewStacks[outletId];
        if (viewStack) {
            const components = viewStacks[outletId].filter(v => v.mount);
            return components;
        }
        return [];
    };
    return {
        clear,
        findViewItemByRouteInfo,
        findLeavingViewItemByRouteInfo,
        createViewItem,
        getChildrenToRender,
        add,
        remove,
        registerIonPage,
        getViewStack
    };
};

const createRouter = (opts) => {
    const routerOptions = Object.assign({}, opts);
    delete routerOptions.tabsPrefix;
    const router = createRouter$1(routerOptions);
    const ionRouter = createIonRouter(opts, router);
    const viewStacks = createViewStacks();
    const oldInstall = router.install.bind(router);
    router.install = (app) => {
        app.provide('navManager', ionRouter);
        app.provide('viewStacks', viewStacks);
        oldInstall(app);
    };
    const oldIsReady = router.isReady.bind(router);
    router.isReady = () => oldIsReady();
    return router;
};
const createWebHistory = (base) => createWebHistory$1(base);
const createWebHashHistory = (base) => createWebHashHistory$1(base);
const createMemoryHistory = (base) => createMemoryHistory$1(base);

export { createMemoryHistory, createRouter, createWebHashHistory, createWebHistory };
//# sourceMappingURL=index.js.map

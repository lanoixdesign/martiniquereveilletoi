{"version":3,"file":"index.min.js","sources":["../dist-transpiled/locationHistory.js","../dist-transpiled/utils.js","../dist-transpiled/router.js","../dist-transpiled/regexp.js","../dist-transpiled/viewStacks.js","../dist-transpiled/index.js"],"sourcesContent":["export const createLocationHistory = () => {\n    const locationHistory = [];\n    const tabsHistory = {};\n    const add = (routeInfo) => {\n        switch (routeInfo.routerAction) {\n            case \"replace\":\n                replaceRoute(routeInfo);\n                break;\n            case \"pop\":\n                pop(routeInfo);\n                break;\n            default:\n                addRoute(routeInfo);\n                break;\n        }\n        if (routeInfo.routerDirection === 'root') {\n            clearHistory();\n            addRoute(routeInfo);\n        }\n    };\n    const update = (routeInfo) => {\n        const locationIndex = locationHistory.findIndex(x => x.id === routeInfo.id);\n        if (locationIndex > -1) {\n            locationHistory.splice(locationIndex, 1, routeInfo);\n        }\n        const tabArray = tabsHistory[routeInfo.tab || ''];\n        if (tabArray) {\n            const tabIndex = tabArray.findIndex(x => x.id === routeInfo.id);\n            if (tabIndex > -1) {\n                tabArray.splice(tabIndex, 1, routeInfo);\n            }\n            else {\n                tabArray.push(routeInfo);\n            }\n        }\n        else if (routeInfo.tab) {\n            tabsHistory[routeInfo.tab] = [routeInfo];\n        }\n    };\n    const replaceRoute = (routeInfo) => {\n        const routeInfos = getTabsHistory(routeInfo.tab);\n        routeInfos && routeInfos.pop();\n        locationHistory.pop();\n        addRoute(routeInfo);\n    };\n    const pop = (routeInfo) => {\n        const tabHistory = getTabsHistory(routeInfo.tab);\n        let ri;\n        if (tabHistory) {\n            // Pop all routes until we are back\n            ri = tabHistory[tabHistory.length - 1];\n            while (ri && ri.id !== routeInfo.id) {\n                tabHistory.pop();\n                ri = tabHistory[tabHistory.length - 1];\n            }\n            // Replace with updated route\n            tabHistory.pop();\n            tabHistory.push(routeInfo);\n        }\n        ri = locationHistory[locationHistory.length - 1];\n        while (ri && ri.id !== routeInfo.id) {\n            locationHistory.pop();\n            ri = locationHistory[locationHistory.length - 1];\n        }\n        // Replace with updated route\n        locationHistory.pop();\n        locationHistory.push(routeInfo);\n    };\n    const addRoute = (routeInfo) => {\n        const tabHistory = getTabsHistory(routeInfo.tab);\n        if (tabHistory) {\n            // If the latest routeInfo is the same (going back and forth between tabs), replace it\n            if (tabHistory[tabHistory.length - 1] && tabHistory[tabHistory.length - 1].id === routeInfo.id) {\n                tabHistory.pop();\n            }\n            tabHistory.push(routeInfo);\n        }\n        locationHistory.push(routeInfo);\n    };\n    const clearHistory = () => {\n        locationHistory.length = 0;\n        Object.keys(tabsHistory).forEach(key => {\n            tabsHistory[key] = [];\n        });\n    };\n    const getTabsHistory = (tab) => {\n        let history;\n        if (tab) {\n            history = tabsHistory[tab];\n            if (!history) {\n                history = tabsHistory[tab] = [];\n            }\n        }\n        return history;\n    };\n    const previous = () => locationHistory[locationHistory.length - 2] || current();\n    const current = () => locationHistory[locationHistory.length - 1];\n    const canGoBack = (deep = 1) => locationHistory.length > deep;\n    const getFirstRouteInfoForTab = (tab) => {\n        const tabHistory = getTabsHistory(tab);\n        if (tabHistory) {\n            return tabHistory[0];\n        }\n        return undefined;\n    };\n    const getCurrentRouteInfoForTab = (tab) => {\n        const tabHistory = getTabsHistory(tab);\n        if (tabHistory) {\n            return tabHistory[tabHistory.length - 1];\n        }\n        return undefined;\n    };\n    const findLastLocation = (routeInfo) => {\n        const routeInfos = getTabsHistory(routeInfo.tab);\n        if (routeInfos) {\n            for (let i = routeInfos.length - 2; i >= 0; i--) {\n                const ri = routeInfos[i];\n                if (ri) {\n                    if (ri.pathname === routeInfo.pushedByRoute) {\n                        return ri;\n                    }\n                }\n            }\n        }\n        for (let i = locationHistory.length - 2; i >= 0; i--) {\n            const ri = locationHistory[i];\n            if (ri) {\n                if (ri.pathname === routeInfo.pushedByRoute) {\n                    return ri;\n                }\n            }\n        }\n        return undefined;\n    };\n    return {\n        current,\n        previous,\n        add,\n        canGoBack,\n        update,\n        getFirstRouteInfoForTab,\n        getCurrentRouteInfoForTab,\n        findLastLocation\n    };\n};\n//# sourceMappingURL=locationHistory.js.map","const ids = { main: 0 };\nexport const generateId = (type = 'main') => {\n    var _a;\n    const id = ((_a = ids[type]) !== null && _a !== void 0 ? _a : 0) + 1;\n    ids[type] = id;\n    return (id).toString();\n};\n//# sourceMappingURL=utils.js.map","import { createLocationHistory } from './locationHistory';\nimport { generateId } from './utils';\nexport const createIonRouter = (opts, router) => {\n    let currentNavigationInfo = { direction: undefined, action: undefined };\n    /**\n     * Ionic Vue should only react to navigation\n     * changes once they have been confirmed and should\n     * never affect the outcome of navigation (with the\n     * exception of going back or selecting a tab).\n     * As a result, we should do our work in afterEach\n     * which is fired once navigation is confirmed\n     * and any user guards have run.\n     */\n    router.afterEach((to, _) => {\n        const { direction, action } = currentNavigationInfo;\n        /**\n         * When calling router.replace, we are not informed\n         * about the replace action in opts.history.listen\n         * but we can check to see if the latest routing action\n         * was a replace action by looking at the history state.\n         */\n        const replaceAction = history.state.replaced ? 'replace' : undefined;\n        handleHistoryChange(to, action || replaceAction, direction);\n        currentNavigationInfo = { direction: undefined, action: undefined };\n    });\n    const locationHistory = createLocationHistory();\n    let currentRouteInfo;\n    let incomingRouteParams;\n    let currentTab;\n    // TODO types\n    let historyChangeListeners = [];\n    if (typeof document !== 'undefined') {\n        document.addEventListener('ionBackButton', (ev) => {\n            ev.detail.register(0, (processNextHandler) => {\n                opts.history.go(-1);\n                processNextHandler();\n            });\n        });\n    }\n    opts.history.listen((_, _x, info) => {\n        /**\n         * history.listen only fires on certain\n         * event such as when the user clicks the\n         * browser back button. It also gives us\n         * additional information as to the type\n         * of navigation (forward, backward, etc).\n         *\n         * We can use this to better handle the\n         * `handleHistoryChange` call in\n         * router.beforeEach\n         */\n        currentNavigationInfo = {\n            action: info.type,\n            direction: info.direction === '' ? 'forward' : info.direction\n        };\n    });\n    const handleNavigateBack = (defaultHref, routerAnimation) => {\n        // todo grab default back button href from config\n        const routeInfo = locationHistory.current();\n        if (routeInfo && routeInfo.pushedByRoute) {\n            const prevInfo = locationHistory.findLastLocation(routeInfo);\n            if (prevInfo) {\n                incomingRouteParams = Object.assign(Object.assign({}, prevInfo), { routerAction: 'pop', routerDirection: 'back', routerAnimation: routerAnimation || routeInfo.routerAnimation });\n                if (routeInfo.lastPathname === routeInfo.pushedByRoute) {\n                    router.back();\n                }\n                else {\n                    router.replace(prevInfo.pathname + (prevInfo.search || ''));\n                }\n            }\n            else {\n                handleNavigate(defaultHref, 'pop', 'back');\n            }\n        }\n        else {\n            handleNavigate(defaultHref, 'pop', 'back');\n        }\n    };\n    const handleNavigate = (path, routerAction, routerDirection, routerAnimation, tab) => {\n        incomingRouteParams = {\n            routerAction,\n            routerDirection,\n            routerAnimation,\n            tab\n        };\n        if (routerAction === 'push') {\n            router.push(path);\n        }\n        else {\n            router.replace(path);\n        }\n    };\n    // TODO RouteLocationNormalized\n    const handleHistoryChange = (location, action, direction) => {\n        let leavingLocationInfo;\n        if (incomingRouteParams) {\n            if (incomingRouteParams.routerAction === 'replace') {\n                leavingLocationInfo = locationHistory.previous();\n            }\n            else {\n                leavingLocationInfo = locationHistory.current();\n            }\n        }\n        else {\n            leavingLocationInfo = locationHistory.current();\n        }\n        if (!leavingLocationInfo) {\n            leavingLocationInfo = {\n                pathname: '',\n                search: ''\n            };\n        }\n        const leavingUrl = leavingLocationInfo.pathname + leavingLocationInfo.search;\n        if (leavingUrl !== location.fullPath) {\n            if (!incomingRouteParams) {\n                if (action === 'replace') {\n                    incomingRouteParams = {\n                        routerAction: 'replace',\n                        routerDirection: 'none',\n                        tab: currentTab\n                    };\n                }\n                else if (action === 'pop') {\n                    const routeInfo = locationHistory.current();\n                    if (routeInfo && routeInfo.pushedByRoute) {\n                        const prevRouteInfo = locationHistory.findLastLocation(routeInfo);\n                        incomingRouteParams = Object.assign(Object.assign({}, prevRouteInfo), { routerAction: 'pop', routerDirection: 'back' });\n                    }\n                    else {\n                        incomingRouteParams = {\n                            routerAction: 'pop',\n                            routerDirection: 'none',\n                            tab: currentTab\n                        };\n                    }\n                }\n                if (!incomingRouteParams) {\n                    incomingRouteParams = {\n                        routerAction: 'push',\n                        routerDirection: direction || 'forward',\n                        tab: currentTab\n                    };\n                }\n            }\n            let routeInfo;\n            if (incomingRouteParams === null || incomingRouteParams === void 0 ? void 0 : incomingRouteParams.id) {\n                routeInfo = Object.assign(Object.assign({}, incomingRouteParams), { lastPathname: leavingLocationInfo.pathname });\n                locationHistory.add(routeInfo);\n            }\n            else {\n                const isPushed = incomingRouteParams.routerAction === 'push' && incomingRouteParams.routerDirection === 'forward';\n                routeInfo = Object.assign(Object.assign({ id: generateId('routeInfo') }, incomingRouteParams), { lastPathname: leavingLocationInfo.pathname, pathname: location.path, search: location.fullPath && location.fullPath.split('?')[1] || '', params: location.params && location.params });\n                if (isPushed) {\n                    routeInfo.tab = leavingLocationInfo.tab;\n                    routeInfo.pushedByRoute = (leavingLocationInfo.pathname !== '') ? leavingLocationInfo.pathname : undefined;\n                }\n                else if (routeInfo.routerAction === 'pop') {\n                    const route = locationHistory.findLastLocation(routeInfo);\n                    routeInfo.pushedByRoute = route === null || route === void 0 ? void 0 : route.pushedByRoute;\n                }\n                else if (routeInfo.routerAction === 'push' && routeInfo.tab !== leavingLocationInfo.tab) {\n                    const lastRoute = locationHistory.getCurrentRouteInfoForTab(routeInfo.tab);\n                    routeInfo.pushedByRoute = lastRoute === null || lastRoute === void 0 ? void 0 : lastRoute.pushedByRoute;\n                }\n                else if (routeInfo.routerAction === 'replace') {\n                    const currentRouteInfo = locationHistory.current();\n                    routeInfo.lastPathname = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.pathname) || routeInfo.lastPathname;\n                    routeInfo.pushedByRoute = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.pushedByRoute) || routeInfo.pushedByRoute;\n                    routeInfo.routerDirection = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.routerDirection) || routeInfo.routerDirection;\n                    routeInfo.routerAnimation = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.routerAnimation) || routeInfo.routerAnimation;\n                }\n                locationHistory.add(routeInfo);\n            }\n            currentRouteInfo = routeInfo;\n        }\n        incomingRouteParams = undefined;\n        historyChangeListeners.forEach(cb => cb(currentRouteInfo));\n    };\n    const getCurrentRouteInfo = () => currentRouteInfo;\n    const canGoBack = (deep = 1) => locationHistory.canGoBack(deep);\n    const navigate = (navigationOptions) => {\n        const { routerAnimation, routerDirection, routerLink } = navigationOptions;\n        incomingRouteParams = {\n            routerAnimation,\n            routerDirection: routerDirection || 'forward',\n            routerAction: 'push'\n        };\n        router.push(routerLink);\n    };\n    const resetTab = (tab, originalHref) => {\n        const routeInfo = locationHistory.getFirstRouteInfoForTab(tab);\n        if (routeInfo) {\n            const newRouteInfo = Object.assign({}, routeInfo);\n            newRouteInfo.pathname = originalHref;\n            incomingRouteParams = Object.assign(Object.assign({}, newRouteInfo), { routerAction: 'pop', routerDirection: 'back' });\n            router.push(newRouteInfo.pathname + (newRouteInfo.search || ''));\n        }\n    };\n    const changeTab = (tab, path) => {\n        const routeInfo = locationHistory.getCurrentRouteInfoForTab(tab);\n        const [pathname] = path.split('?');\n        if (routeInfo) {\n            const search = (routeInfo.search) ? `?${routeInfo.search}` : '';\n            incomingRouteParams = Object.assign(Object.assign({}, incomingRouteParams), { routerAction: 'push', routerDirection: 'none', tab });\n            /**\n             * When going back to a tab\n             * you just left, it's possible\n             * for the route info to be incorrect\n             * as the tab you want is not the\n             * tab you are on.\n             */\n            if (routeInfo.pathname === pathname) {\n                router.push(routeInfo.pathname + search);\n            }\n            else {\n                router.push(pathname + search);\n            }\n        }\n        else {\n            handleNavigate(pathname, 'push', 'none', undefined, tab);\n        }\n    };\n    const handleSetCurrentTab = (tab) => {\n        currentTab = tab;\n        const ri = Object.assign({}, locationHistory.current());\n        if (ri.tab !== tab) {\n            ri.tab = tab;\n            locationHistory.update(ri);\n        }\n    };\n    // TODO types\n    const registerHistoryChangeListener = (cb) => {\n        historyChangeListeners.push(cb);\n    };\n    return {\n        handleNavigateBack,\n        handleSetCurrentTab,\n        getCurrentRouteInfo,\n        canGoBack,\n        navigate,\n        resetTab,\n        changeTab,\n        registerHistoryChangeListener\n    };\n};\n//# sourceMappingURL=router.js.map","// @ts-nocheck\n// https://github.com/pillarjs/path-to-regexp\n// Included here so we do not need to add additional package.json dependency\n/**\n * Tokenize input string.\n */\nfunction lexer(str) {\n    const tokens = [];\n    let i = 0;\n    while (i < str.length) {\n        const char = str[i];\n        if (char === \"*\" || char === \"+\" || char === \"?\") {\n            tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"\\\\\") {\n            tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n            continue;\n        }\n        if (char === \"{\") {\n            tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"}\") {\n            tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \":\") {\n            let name = \"\";\n            let j = i + 1;\n            while (j < str.length) {\n                const code = str.charCodeAt(j);\n                if (\n                // `0-9`\n                (code >= 48 && code <= 57) ||\n                    // `A-Z`\n                    (code >= 65 && code <= 90) ||\n                    // `a-z`\n                    (code >= 97 && code <= 122) ||\n                    // `_`\n                    code === 95) {\n                    name += str[j++];\n                    continue;\n                }\n                break;\n            }\n            if (!name)\n                throw new TypeError(`Missing parameter name at ${i}`);\n            tokens.push({ type: \"NAME\", index: i, value: name });\n            i = j;\n            continue;\n        }\n        if (char === \"(\") {\n            let count = 1;\n            let pattern = \"\";\n            let j = i + 1;\n            if (str[j] === \"?\") {\n                throw new TypeError(`Pattern cannot start with \"?\" at ${j}`);\n            }\n            while (j < str.length) {\n                if (str[j] === \"\\\\\") {\n                    pattern += str[j++] + str[j++];\n                    continue;\n                }\n                if (str[j] === \")\") {\n                    count--;\n                    if (count === 0) {\n                        j++;\n                        break;\n                    }\n                }\n                else if (str[j] === \"(\") {\n                    count++;\n                    if (str[j + 1] !== \"?\") {\n                        throw new TypeError(`Capturing groups are not allowed at ${j}`);\n                    }\n                }\n                pattern += str[j++];\n            }\n            if (count)\n                throw new TypeError(`Unbalanced pattern at ${i}`);\n            if (!pattern)\n                throw new TypeError(`Missing pattern at ${i}`);\n            tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n            i = j;\n            continue;\n        }\n        tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n    }\n    tokens.push({ type: \"END\", index: i, value: \"\" });\n    return tokens;\n}\n/**\n * Parse a string for the raw tokens.\n */\nexport function parse(str, options = {}) {\n    const tokens = lexer(str);\n    const { prefixes = \"./\" } = options;\n    const defaultPattern = `[^${escapeString(options.delimiter || \"/#?\")}]+?`;\n    const result = [];\n    let key = 0;\n    let i = 0;\n    let path = \"\";\n    const tryConsume = (type) => {\n        if (i < tokens.length && tokens[i].type === type)\n            return tokens[i++].value;\n    };\n    const mustConsume = (type) => {\n        const value = tryConsume(type);\n        if (value !== undefined)\n            return value;\n        const { type: nextType, index } = tokens[i];\n        throw new TypeError(`Unexpected ${nextType} at ${index}, expected ${type}`);\n    };\n    const consumeText = () => {\n        let result = \"\";\n        let value;\n        // tslint:disable-next-line\n        while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n            result += value;\n        }\n        return result;\n    };\n    while (i < tokens.length) {\n        const char = tryConsume(\"CHAR\");\n        const name = tryConsume(\"NAME\");\n        const pattern = tryConsume(\"PATTERN\");\n        if (name || pattern) {\n            let prefix = char || \"\";\n            if (prefixes.indexOf(prefix) === -1) {\n                path += prefix;\n                prefix = \"\";\n            }\n            if (path) {\n                result.push(path);\n                path = \"\";\n            }\n            result.push({\n                name: name || key++,\n                prefix,\n                suffix: \"\",\n                pattern: pattern || defaultPattern,\n                modifier: tryConsume(\"MODIFIER\") || \"\"\n            });\n            continue;\n        }\n        const value = char || tryConsume(\"ESCAPED_CHAR\");\n        if (value) {\n            path += value;\n            continue;\n        }\n        if (path) {\n            result.push(path);\n            path = \"\";\n        }\n        const open = tryConsume(\"OPEN\");\n        if (open) {\n            const prefix = consumeText();\n            const name = tryConsume(\"NAME\") || \"\";\n            const pattern = tryConsume(\"PATTERN\") || \"\";\n            const suffix = consumeText();\n            mustConsume(\"CLOSE\");\n            result.push({\n                name: name || (pattern ? key++ : \"\"),\n                pattern: name && !pattern ? defaultPattern : pattern,\n                prefix,\n                suffix,\n                modifier: tryConsume(\"MODIFIER\") || \"\"\n            });\n            continue;\n        }\n        mustConsume(\"END\");\n    }\n    return result;\n}\n/**\n * Compile a string to a template function for the path.\n */\nexport function compile(str, options) {\n    return tokensToFunction(parse(str, options), options);\n}\n/**\n * Expose a method for transforming tokens into the path function.\n */\nexport function tokensToFunction(tokens, options = {}) {\n    const reFlags = flags(options);\n    const { encode = (x) => x, validate = true } = options;\n    // Compile all the tokens into regexps.\n    const matches = tokens.map(token => {\n        if (typeof token === \"object\") {\n            return new RegExp(`^(?:${token.pattern})$`, reFlags);\n        }\n    });\n    return (data) => {\n        let path = \"\";\n        for (let i = 0; i < tokens.length; i++) {\n            const token = tokens[i];\n            if (typeof token === \"string\") {\n                path += token;\n                continue;\n            }\n            const value = data ? data[token.name] : undefined;\n            const optional = token.modifier === \"?\" || token.modifier === \"*\";\n            const repeat = token.modifier === \"*\" || token.modifier === \"+\";\n            if (Array.isArray(value)) {\n                if (!repeat) {\n                    throw new TypeError(`Expected \"${token.name}\" to not repeat, but got an array`);\n                }\n                if (value.length === 0) {\n                    if (optional)\n                        continue;\n                    throw new TypeError(`Expected \"${token.name}\" to not be empty`);\n                }\n                for (let j = 0; j < value.length; j++) {\n                    const segment = encode(value[j], token);\n                    if (validate && !matches[i].test(segment)) {\n                        throw new TypeError(`Expected all \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`);\n                    }\n                    path += token.prefix + segment + token.suffix;\n                }\n                continue;\n            }\n            if (typeof value === \"string\" || typeof value === \"number\") {\n                const segment = encode(String(value), token);\n                if (validate && !matches[i].test(segment)) {\n                    throw new TypeError(`Expected \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`);\n                }\n                path += token.prefix + segment + token.suffix;\n                continue;\n            }\n            if (optional)\n                continue;\n            const typeOfMessage = repeat ? \"an array\" : \"a string\";\n            throw new TypeError(`Expected \"${token.name}\" to be ${typeOfMessage}`);\n        }\n        return path;\n    };\n}\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nexport function match(str, options) {\n    const keys = [];\n    const re = pathToRegexp(str, keys, options);\n    return regexpToFunction(re, keys, options);\n}\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nexport function regexpToFunction(re, keys, options = {}) {\n    const { decode = (x) => x } = options;\n    return function (pathname) {\n        const m = re.exec(pathname);\n        if (!m)\n            return false;\n        const { 0: path, index } = m;\n        const params = Object.create(null);\n        for (let i = 1; i < m.length; i++) {\n            // tslint:disable-next-line\n            if (m[i] === undefined)\n                continue;\n            const key = keys[i - 1];\n            if (key.modifier === \"*\" || key.modifier === \"+\") {\n                params[key.name] = m[i].split(key.prefix + key.suffix).map(value => {\n                    return decode(value, key);\n                });\n            }\n            else {\n                params[key.name] = decode(m[i], key);\n            }\n        }\n        return { path, index, params };\n    };\n}\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str) {\n    return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options) {\n    return options && options.sensitive ? \"\" : \"i\";\n}\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path, keys) {\n    if (!keys)\n        return path;\n    const groupsRegex = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\n    let index = 0;\n    let execResult = groupsRegex.exec(path.source);\n    while (execResult) {\n        keys.push({\n            // Use parenthesized substring match if available, index otherwise\n            name: execResult[1] || index++,\n            prefix: \"\",\n            suffix: \"\",\n            modifier: \"\",\n            pattern: \"\"\n        });\n        execResult = groupsRegex.exec(path.source);\n    }\n    return path;\n}\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(paths, keys, options) {\n    const parts = paths.map(path => pathToRegexp(path, keys, options).source);\n    return new RegExp(`(?:${parts.join(\"|\")})`, flags(options));\n}\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(path, keys, options) {\n    return tokensToRegexp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nexport function tokensToRegexp(tokens, keys, options = {}) {\n    const { strict = false, start = true, end = true, encode = (x) => x } = options;\n    const endsWith = `[${escapeString(options.endsWith || \"\")}]|$`;\n    const delimiter = `[${escapeString(options.delimiter || \"/#?\")}]`;\n    let route = start ? \"^\" : \"\";\n    // Iterate over the tokens and create our regexp string.\n    for (const token of tokens) {\n        if (typeof token === \"string\") {\n            route += escapeString(encode(token));\n        }\n        else {\n            const prefix = escapeString(encode(token.prefix));\n            const suffix = escapeString(encode(token.suffix));\n            if (token.pattern) {\n                if (keys)\n                    keys.push(token);\n                if (prefix || suffix) {\n                    if (token.modifier === \"+\" || token.modifier === \"*\") {\n                        const mod = token.modifier === \"*\" ? \"?\" : \"\";\n                        route += `(?:${prefix}((?:${token.pattern})(?:${suffix}${prefix}(?:${token.pattern}))*)${suffix})${mod}`;\n                    }\n                    else {\n                        route += `(?:${prefix}(${token.pattern})${suffix})${token.modifier}`;\n                    }\n                }\n                else {\n                    route += `(${token.pattern})${token.modifier}`;\n                }\n            }\n            else {\n                route += `(?:${prefix}${suffix})${token.modifier}`;\n            }\n        }\n    }\n    if (end) {\n        if (!strict)\n            route += `${delimiter}?`;\n        route += !options.endsWith ? \"$\" : `(?=${endsWith})`;\n    }\n    else {\n        const endToken = tokens[tokens.length - 1];\n        const isEndDelimited = typeof endToken === \"string\"\n            ? delimiter.indexOf(endToken[endToken.length - 1]) > -1\n            : // tslint:disable-next-line\n                endToken === undefined;\n        if (!strict) {\n            route += `(?:${delimiter}(?=${endsWith}))?`;\n        }\n        if (!isEndDelimited) {\n            route += `(?=${delimiter}|${endsWith})`;\n        }\n    }\n    return new RegExp(route, flags(options));\n}\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nexport function pathToRegexp(path, keys, options) {\n    if (path instanceof RegExp)\n        return regexpToRegexp(path, keys);\n    if (Array.isArray(path))\n        return arrayToRegexp(path, keys, options);\n    return stringToRegexp(path, keys, options);\n}\n//# sourceMappingURL=regexp.js.map","import { generateId } from './utils';\nimport { pathToRegexp } from './regexp';\nimport { shallowRef } from 'vue';\nexport const createViewStacks = () => {\n    let viewStacks = {};\n    const clear = (outletId) => {\n        delete viewStacks[outletId];\n    };\n    const getViewStack = (outletId) => {\n        return viewStacks[outletId];\n    };\n    const registerIonPage = (viewItem, ionPage) => {\n        viewItem.ionPageElement = ionPage;\n    };\n    const findViewItemByRouteInfo = (routeInfo, outletId) => {\n        return findViewItemByPath(routeInfo.pathname, outletId);\n    };\n    const findLeavingViewItemByRouteInfo = (routeInfo, outletId) => {\n        return findViewItemByPath(routeInfo.lastPathname, outletId, false);\n    };\n    const findViewItemInStack = (path, stack) => {\n        return stack.find((viewItem) => {\n            if (viewItem.pathname === path) {\n                return viewItem;\n            }\n            return undefined;\n        });\n    };\n    const findViewItemByPath = (path, outletId, strict = true) => {\n        const matchView = (viewItem) => {\n            const pathname = path;\n            const viewItemPath = viewItem.matchedRoute.path;\n            const regexp = pathToRegexp(viewItemPath, [], {\n                end: viewItem.exact,\n                strict: viewItem.exact,\n                sensitive: false\n            });\n            return (regexp.exec(pathname)) ? viewItem : undefined;\n        };\n        if (outletId) {\n            const stack = viewStacks[outletId];\n            if (!stack)\n                return undefined;\n            const quickMatch = findViewItemInStack(path, stack);\n            if (quickMatch)\n                return quickMatch;\n            if (!strict) {\n                const match = stack.find(matchView);\n                if (match)\n                    return match;\n            }\n        }\n        else {\n            for (let outletId in viewStacks) {\n                const stack = viewStacks[outletId];\n                const viewItem = findViewItemInStack(path, stack);\n                if (viewItem) {\n                    return viewItem;\n                }\n            }\n        }\n        return undefined;\n    };\n    const createViewItem = (outletId, vueComponent, matchedRoute, routeInfo, ionPage) => {\n        return {\n            id: generateId('viewItem'),\n            pathname: routeInfo.pathname,\n            outletId,\n            matchedRoute,\n            ionPageElement: ionPage,\n            vueComponent,\n            vueComponentRef: shallowRef(),\n            ionRoute: false,\n            mount: false,\n            exact: routeInfo.pathname === matchedRoute.path\n        };\n    };\n    const add = (viewItem) => {\n        const { outletId } = viewItem;\n        if (!viewStacks[outletId]) {\n            viewStacks[outletId] = [viewItem];\n        }\n        else {\n            viewStacks[outletId].push(viewItem);\n        }\n    };\n    const remove = (viewItem, outletId) => {\n        if (!outletId) {\n            throw Error('outletId required');\n        }\n        const viewStack = viewStacks[outletId];\n        if (viewStack) {\n            viewStacks[outletId] = viewStack.filter(item => item.id !== viewItem.id);\n        }\n    };\n    const getChildrenToRender = (outletId) => {\n        const viewStack = viewStacks[outletId];\n        if (viewStack) {\n            const components = viewStacks[outletId].filter(v => v.mount);\n            return components;\n        }\n        return [];\n    };\n    return {\n        clear,\n        findViewItemByRouteInfo,\n        findLeavingViewItemByRouteInfo,\n        createViewItem,\n        getChildrenToRender,\n        add,\n        remove,\n        registerIonPage,\n        getViewStack\n    };\n};\n//# sourceMappingURL=viewStacks.js.map","import { createRouter as createVueRouter, createWebHistory as createVueWebHistory, createWebHashHistory as createVueWebHashHistory, createMemoryHistory as createVueMemoryHistory } from 'vue-router';\nimport { createIonRouter } from './router';\nimport { createViewStacks } from './viewStacks';\nexport const createRouter = (opts) => {\n    const routerOptions = Object.assign({}, opts);\n    delete routerOptions.tabsPrefix;\n    const router = createVueRouter(routerOptions);\n    const ionRouter = createIonRouter(opts, router);\n    const viewStacks = createViewStacks();\n    const oldInstall = router.install.bind(router);\n    router.install = (app) => {\n        app.provide('navManager', ionRouter);\n        app.provide('viewStacks', viewStacks);\n        oldInstall(app);\n    };\n    const oldIsReady = router.isReady.bind(router);\n    router.isReady = () => oldIsReady();\n    return router;\n};\nexport const createWebHistory = (base) => createVueWebHistory(base);\nexport const createWebHashHistory = (base) => createVueWebHashHistory(base);\nexport const createMemoryHistory = (base) => createVueMemoryHistory(base);\n//# sourceMappingURL=index.js.map"],"names":["ids","main","generateId","type","_a","id","toString","createIonRouter","opts","router","currentNavigationInfo","direction","undefined","action","afterEach","to","_","replaceAction","history","state","replaced","handleHistoryChange","locationHistory","tabsHistory","replaceRoute","routeInfo","routeInfos","getTabsHistory","tab","pop","addRoute","tabHistory","ri","length","push","clearHistory","Object","keys","forEach","key","current","previous","add","routerAction","routerDirection","canGoBack","deep","update","locationIndex","findIndex","x","splice","tabArray","tabIndex","getFirstRouteInfoForTab","getCurrentRouteInfoForTab","findLastLocation","i","pathname","pushedByRoute","createLocationHistory","currentRouteInfo","incomingRouteParams","currentTab","historyChangeListeners","document","addEventListener","ev","detail","register","processNextHandler","go","listen","_x","info","handleNavigate","path","routerAnimation","replace","location","leavingLocationInfo","search","fullPath","prevRouteInfo","assign","lastPathname","isPushed","split","params","route","lastRoute","cb","handleNavigateBack","defaultHref","prevInfo","back","handleSetCurrentTab","getCurrentRouteInfo","navigate","navigationOptions","routerLink","resetTab","originalHref","newRouteInfo","changeTab","registerHistoryChangeListener","parse","str","options","tokens","char","index","value","count","pattern","j","TypeError","name","code","charCodeAt","lexer","prefixes","defaultPattern","escapeString","delimiter","result","tryConsume","mustConsume","nextType","consumeText","prefix","indexOf","suffix","modifier","flags","sensitive","stringToRegexp","strict","start","end","encode","endsWith","token","mod","endToken","isEndDelimited","RegExp","tokensToRegexp","pathToRegexp","groupsRegex","execResult","exec","source","regexpToRegexp","Array","isArray","paths","parts","map","join","arrayToRegexp","createRouter","routerOptions","tabsPrefix","createVueRouter","ionRouter","viewStacks","findViewItemInStack","stack","find","viewItem","findViewItemByPath","outletId","matchView","matchedRoute","exact","quickMatch","match","clear","findViewItemByRouteInfo","findLeavingViewItemByRouteInfo","createViewItem","vueComponent","ionPage","ionPageElement","vueComponentRef","shallowRef","ionRoute","mount","getChildrenToRender","filter","v","remove","Error","viewStack","item","registerIonPage","getViewStack","createViewStacks","oldInstall","install","bind","app","provide","oldIsReady","isReady","createWebHistory","base","createVueWebHistory","createWebHashHistory","createVueWebHashHistory","createMemoryHistory","createVueMemoryHistory"],"mappings":"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"}